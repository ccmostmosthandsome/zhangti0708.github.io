[{"title":"cesium | 警情分析城市火灾模拟示例","date":"2020-06-18T09:57:00.000Z","path":"2020/06/18/cesium-警情分析城市火灾模拟/","text":"效果火灾 积水 在线地址：点击访问","tags":[{"name":"GIS","slug":"GIS","permalink":"http://yoursite.com/tags/GIS/"}]},{"title":"[cesium]自定义雷达探测传感器效果","date":"2020-05-28T03:41:00.000Z","path":"2020/05/28/cesium-自定义雷达探测传感器效果/","text":"效果简单粗暴直接上效果 相控雷达传感器 球形相控雷达传感器 信息传输 卫星视锥 雷达跟踪 雷达探测 雷达测控 空间网 插件地址：github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"[cesium]新版本czm内置函数更换","date":"2020-05-28T03:22:00.000Z","path":"2020/05/28/cesium-新版本czm内置函数更换/","text":"前言1记录修改shader和cesium版本迭代替换的一些变量函数。 替换czm_phong12341.5x 之前gl_FragColor &#x3D; czm_phong(normalize(positionToEyeEC), material) 12341.6x 之后gl_FragColor &#x3D; czm_phong(normalize(positionToEyeEC), material, lightDirectionEC) czm_ellipsoidInverseRadii12345671.5x 之前float ellipsoidSurfaceFunction(czm_ellipsoid ellipsoid, vec3 point)&#123; vec3 scaled &#x3D; ellipsoid.inverseRadii * point; return dot(scaled, scaled) - 1.0;&#125; 12345671.6x 之后float ellipsoidSurfaceFunction(vec3 point)&#123; vec3 scaled &#x3D; czm_ellipsoidInverseRadii * point; return dot(scaled, scaled) - 1.0;&#125;","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"[cesium]基于cesium城市效果示例","date":"2020-05-26T10:46:00.000Z","path":"2020/05/26/cesium-基于cesium城市效果/","text":"效果效果1 效果2 材质动态泛光墙 流动粒子线 od线 说明用的城市白膜，更具不同高度定义颜色 动态效果是自定义的材质和扩散扫描的效果 后续准备加入一些three定义图形 在线地址：点击访问","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"threeJs|开源示例和可视化 (1)","date":"2020-05-25T11:42:00.000Z","path":"2020/05/25/threeJs-开源示例和可视化/","text":"前言1234567891011OpenGL大概许多人都有所耳闻，它是最常用的跨平台图形库。WebGL是基于OpenGL设计的面向web的图形标准，提供了一系列JavaScript API，通过这些API进行图形渲染将得以利用图形硬件从而获得较高性能。 而Three.js是通过对WebGL接口的封装与简化而形成的一个易用的图形库。简单点的说法：WebGL可以看成是浏览器给我们提供的接口，在javascript中可以直接用这些API进行3D图形的绘制；而Three.js就是在这些接口上又帮我们封装得更好用一些。 学习官网： https://threejs.org/ 知乎介绍： https://zhuanlan.zhihu.com/p/23272116?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1018420095655288832 入门指南： https://www.ituring.com.cn/book/1272 在线示例： https://threejs.org/examples/ 开源地址github： https://github.com/mrdoob/three.js three相关资料： https://github.com/chenjsh36/ThreeJSForFun 实现RayData智慧城市： https://zhuanlan.zhihu.com/p/66395021?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1018420095655288832 web3D城市交通： https://zhuanlan.zhihu.com/p/55457466 three示例： https://yyhsong.github.io/iThreeJS/ CesiumThree：https://blog.csdn.net/qq_36266612/article/details/88943501 cesium整合Three示例","tags":[{"name":"ThreeJs","slug":"ThreeJs","permalink":"http://yoursite.com/tags/ThreeJs/"}]},{"title":"cesium | 自定义材质泛光面","date":"2020-05-18T07:31:00.000Z","path":"2020/05/18/cesium-自定义材质泛光面/","text":"效果 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const DEF_OPT &#x3D; &#123; color: Cesium.Color.BLUE, duration: 3000, count: 2.0, freely: &#39;vertical&#39;, direction: &#39;-&#39;&#125;CV.PolylineTrailLinkMaterialProperty &#x3D; class &#123; constructor(options) &#123; options &#x3D; options || DEF_OPT this._definitionChanged &#x3D; new Cesium.Event(); this._color &#x3D; undefined; this._colorSubscription &#x3D; undefined; this.color &#x3D; options.color; this.duration &#x3D; options.duration; this._time &#x3D; new Date().getTime(); this.create(options) &#125; get isConstant() &#123; return false &#125; get definitionChanged() &#123; return this._definitionChanged &#125; getType(time) &#123; return &quot;PolylineTrailLink&quot;; &#125; getValue (time, result) &#123; if (!Cesium.defined(result)) &#123; result &#x3D; &#123;&#125;; &#125; result.color &#x3D; Cesium.Property.getValueOrClonedDefault( this._color, time, Cesium.Color.WHITE, result.color ); result.image &#x3D; Cesium.Material.PolylineTrailLinkImage; result.time &#x3D; ((new Date().getTime() - this._time) % this.duration) &#x2F; this.duration; return result; &#125;; equals(other) &#123; return ( this &#x3D;&#x3D;&#x3D; other || (other instanceof CV.PolylineTrailLinkMaterialProperty &amp;&amp; Cesium.Property.equals(this._color, other._color)) ); &#125; getMaterail(options) &#123; let materail &#x3D; 【定义的shader材质,csdn博客实现】 &#125; create(options) &#123; Cesium.Material.PolylineTrailLinkType &#x3D; &quot;PolylineTrailLink&quot;; Cesium.Material.PolylineTrailLinkImage &#x3D; options.image || &quot;&#x2F;examples&#x2F;images&#x2F;color1.png&quot;; &#x2F;&#x2F;图片 Cesium.Material.PolylineTrailLinkSource &#x3D; this.getMaterail(options) Cesium.Material._materialCache.addMaterial( Cesium.Material.PolylineTrailLinkType, &#123; fabric: &#123; type: Cesium.Material.PolylineTrailLinkType, uniforms: &#123; color: new Cesium.Color(1.0, 0.0, 0.0, 0.5), image: Cesium.Material.PolylineTrailLinkImage, time: 0 &#125;, source: Cesium.Material.PolylineTrailLinkSource &#125;, translucent: function (material) &#123; return true; &#125; &#125; ); &#125;&#125;Object.defineProperties(CV.PolylineTrailLinkMaterialProperty.prototype, &#123; color: Cesium.createPropertyDescriptor(&quot;color&quot;)&#125;); 使用1234entity方式：设置材质material: new CV.PolylineTrailLinkMaterialProperty()","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"随笔| web资料整合","date":"2020-04-30T12:03:00.000Z","path":"2020/04/30/随笔-资料整合/","text":"一. 知识体系: 综合类前端知识体系 前端知识结构 Web前端开发大系概览 Web前端开发大系概览-中文版 Web Front-end Stack v2.2 免费的编程中文书籍索引 前端书籍 前端免费书籍大全 前端知识体系 免费的编程中文书籍索引 智能社 - 精通JavaScript开发 重新介绍 JavaScript（JS 教程） 麻省理工学院公开课：计算机科学及编程导论 JavaScript中的this陷阱的最全收集--没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 腾讯移动Web前端知识库 Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 - 聂微东 前端开发者手册 入门类 前端入门教程 瘳雪峰的Javascript教程 jQuery基础教程 前端工程师必备的PS技能——切图篇 结合个人经历总结的前端入门方法 效果类 弹出层 焦点图轮播特效 工具类 css sprite 雪碧图制作 版本控制入门 – 搬进 Github Grunt-beginner前端自动化工具 慕课专题 张鑫旭 - 慕课系列 lyn - 慕课系列 艾伦 - 慕课系列 碧仔 - Hello，移动WEB 周刊类 百度FEX技术周刊 平安科技移动开发二队技术周报 360奇舞周刊 二. API: 1. 总目录 开发中心 mozilla js参考 chrome开发中心（chrome的内核已转向blink） safari开发中心 microsoft js参考 js秘密花园 js秘密花园 w3help&nbsp;综合Bug集合网站 综合搜索 javascripting 各种流行库搜索 综合API runoob.com-包含各种API集合 开源中国在线API文档合集 devdocs&nbsp;英文综合API网站 2. jQuery jQuery API 中文文档 hemin 在线版 css88 jq api css88 jqui api 学习jquery jquery 源码查找 3. Ecmascript Understanding ECMAScript 6 - Nicholas C. Zakas exploring-es6 exploring-es6翻译 exploring-es6翻译后预览 阮一峰 es6 阮一峰 Javascript ECMA-262，第 5 版 es5 4. Js template template-chooser artTemplate tomdjs 淘宝模板juicer模板 Fxtpl v1.0 繁星前端模板引擎 laytpl mozilla - nunjucks Juicer dustjs etpl twitter-tpl 5. 弹出层 artDialog 最新版 artDialog 文档 google code 下载地址 贤心弹出层 响应式用户交互组件库 sweetalert-有css3动画弹出层 6. CSS CSS 语法参考 CSS3动画手册 腾讯css3动画制作工具 志爷css小工具集合 css3 js 移动大杂烩 bouncejs 触摸库 css3 按钮动画 animate.css 全局CSS的终结(狗带) [译] 7. Angularjs Angular.js 的一些学习资源 angularjs中文社区 Angular Style Guide Angularjs源码学习 Angularjs源码学习 angular对bootstrap的封装 angularjs + nodejs 吕大豹 Angularjs AngularJS 最佳实践 Angular的一些扩展指令 Angular数据绑定原理 一些扩展Angular UI组件 Ember和AngularJS的性能测试 带你走近AngularJS - 基本功能介绍 Angularjs开发指南 Angularjs学习 不要带着jQuery的思维去学习AngularJS angularjs 学习笔记 angularjs 开发指南 angularjs 英文资料 angular bootstrap angular jq mobile angular ui 整合jQuery Mobile+AngularJS经验谈 有jQuery背景，该如何用AngularJS编程思想 AngularJS在线教程 angular学习笔记 8. React react海量资源 react.js 中文论坛 react.js 官方网址 react.js 官方文档 react.js material UI react.js TouchstoneJS UI react.js amazeui UI React 入门实例教程 - 阮一峰 React Native 中文版 Webpack 和 React 小书 - 前端乱炖 Webpack 和 React 小书 - gitbook React原创实战视频教程 React 入门教程 react-webpack-starter 基于react组件化开发 9. 移动端API API 99移动端知识集合 移动端前端开发知识库 移动前端的一些坑和解决方法（外观表现） 【原】移动web资源整理 zepto 1.0 中文手册 zepto 1.0 中文手册 zepto 1.1.2 zepto 中文注释 jqmobile 手册 移动浏览器开发集合 移动开发大杂烩 微信webview中的一些问题 框架 特色的HTML框架可以创建精美的iOS应用 淘宝SUI 10. avalon avalonjs Avalon新一代UI库： OniUI avalon.oniui-基于avalon的组件库 11. Requriejs Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 RequireJS入门（一） RequireJS入门（二） RequireJS进阶（三） requrie源码学习 requrie 入门指南 requrieJS 学习笔记 requriejs 其一 require backbone结合 12. Seajs seajs seajs 中文手册 13. Less,sass sass sass教程-sass中国 Sass 中文文档 less 14. Markdown Markdown 语法说明 (简体中文版) markdown入门参考 gitbook&nbsp;国外的在线markdown可编辑成书 mdeditor&nbsp;一款国内的在线markdown编辑器 stackedit&nbsp;国外的在线markdown编辑器，功能强大，同步云盘 mditor&nbsp;一款轻量级的markdown编辑器 lepture-editor markdown-editor 15. D3 d3 Tutorials Gallery lofter iteye ruanyifeng 16. 兼容性 esma 兼容列表 W3C CSS验证服务 caniuse csscreator microsoft 在线测兼容-移动端 emulators 17. UI相关 bootcss MetroUICSS semantic Buttons kitecss pintuer amazeui worldhello linuxtoy gitmagic rogerdudler gitref book gogojimmy 18. HTTP HTTP API 设计指南 19. 其它API javascript流行库汇总 验证api underscore 中文手册 underscore源码分析 underscore源码分析-亚里士朱德的博客 underscrejs en api lodash - underscore的代替品 ext4api backbone 中文手册 qwrap手册 缓动函数 svg 中文参考 svg mdn参考 svg 导出 canvas svg 导出 png ai-to-svg localStorage 库 20. 图表类 Highcharts 中文API Highcharts 英文API ECharts 百度的图表软件 高德地图 开源的矢量图脚本框架 svg 地图 21. vue Vue Vue 论坛 Vue 入门指南 Vue 的一些资源索引 21. 正则 JS正则表达式元字符 正则表达式30分钟入门教程 MDN-正则表达式 ruanyifeng - RegExp对象 小胡子哥 - 进阶正则表达式 is.js 正则在线测试 22. ionic ionic 23. 其它 Mock.js 是一款模拟数据生成器 三. 开发规范 前端 通过分析github代码库总结出来的工程师代码书写习惯 HTML&amp;CSS编码规范 by @mdo 团队合作的css命名规范-腾讯AlloyTeam前端团队 前端编码规范之js - by yuwenhui 前端编码规范之js - by 李靖 前端开发规范手册 Airbnb JavaScript 编码规范（简体中文版） AMD与CMD规范的区别 AMD与CMD规范的区别 KISSY 源码规范 bt编码规范 规范加强版 前端代码规范 及 最佳实践 百度前端规范 百度前端规范 百度前端规范 ECMAScript6 编码规范--广发证券前端团队 JavaScript 风格指南/编码规范（Airbnb公司版） 网易前端开发规范 css模块 前端规范资源列表 Nodejs Node.js 风格指南 PHP 最流行的PHP 代码规范 最流行的PHP 代码规范 Android 【敏捷开发】Android团队开发规范 Android 开发规范与应用 四. 其它收集 1. 各大公司开源项目 Facebook Projects 百度web前端研发部 百度EFE 百度github alloyteam alloyteam-github alloyteam-AlloyGameEngine AlloyDesigner&nbsp;即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍&nbsp;H5动画交互页开发的工具介绍 AEditor&nbsp;H5动画交互页开发的工具 maka 值得订阅的weekly 腾讯html5 奇舞团开源项目 Qunar UED 2. Javascript 常用 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 模拟键盘 拼音 中国个人身份证号验证 算法 数据结构与算法 JavaScript 描述. 章节练习 常见排序算法（JS版） 经典排序 常见排序算法-js版本 JavaScript 算法与数据结构 精华集 面试常考算法题精讲 移动端 fastclick no-click-delay JSON 模拟生成JSON数据 返回跨域JSONAPI 3. Html5 HTML5 有哪些让你惊艳的 demo？ html5 Canvas画图系列教程目录 4. CSS browserhacks 5. jQuery 焦点图 myfocus myfocus-官方演示站 SuperSlidev2.1 -- 大话主席 soChange 6. Ext, EasyUI, J-UI 及其它各种UI方案 Ext extjs ext4英文api ext4中文api EasyUI jquery easyui 未压缩源代码 J-UI J-UI Other MUI-最接近原生APP体验的高性能前端框架 Amaze UI | 中国首个开源 HTML5 跨屏前端框架 淘宝 HTML5 前端框架 KISSY - 阿里前端JavaScript库 网易Nej - Nice Easy Javascript Kendo UI MVVM Demo Bootstrap Smart UI 雅虎UI - CSS UI 7. 页面 社会化 分享功能 百度分享&nbsp;pc端 JiaThis&nbsp;pc端 社会化分享组件&nbsp;移动端 ShareSDK 轻松实现社会化功能&nbsp;移动端 友盟分享&nbsp;移动端 8. 富文本编辑器 百度 ueditor 经典的ckeditor 经典的kindeditor wysiwyg 一个有情怀的编辑器。Bach's Editor tower用的编辑器 summernote 编辑器 html5编辑器 XEditor wangEditor Trumbowyg - 轻量编辑器 9. 日历 PC 经典my97 强大的独立日期选择器 fullcalendar fullcalendar日历控件知识点集合 中文api 农历日历 超酷的仿百度带节日日历老黄历控件 日期格式化 大牛日历控件 我群某管理作品 input按位替换-官网 input按位替换-github bootstrap-daterangepicker 国外30个插件集合 JavaScript datepicker Datepair.js 一个风格多样的日历 弹出层式的全日历 jquery双日历 移动 大气实用jQuery手机移动端日历日期选择插件 jQuery Mobile 移动开发中的日期插件Mobiscroll Date library Datejs sugarjs 10. 综合效果搜索平台 效果网 17素材 常用的JavaScript代码片段 11. 前端工程化 概述 前端工具大全 什么是前端工程化 Gulp Gulp官网 Gulp中文网 gulp资料收集 Gulp：任务自动管理工具 - ruanyifeng Gulp插件 Gulp不完全入门教程 为什么使用gulp? Gulp安装及配合组件构建前端开发一体化 Gulp 入门指南 Gulp 入门指南 - nimojs Gulp入门教程 Gulp in Action Gulp开发教程（翻译） 前端构建工具gulpjs的使用介绍及技巧 Grunt gruntjs Grunt中文网 Fis fis 官网 fis webpack webpack Webpack，101入门体验 webpack入门教程 基于webpack搭建前端工程解决方案探索 Webpack傻瓜式指南（一） Webpack指南 12. 轮播图 pc图轮 单屏轮播sochange 左右按钮多图切换 fullpage全屏轮播 移动端 无缝切换 滑屏效果 全屏fullpage 单个图片切换 单个全屏切换 百度的切换库 单个全屏切换 滑屏效果 旋转拖动设置 类似于swipe切换 支持多种形式的触摸滑动 滑屏效果 大话主席pc移动图片轮换 滑屏效果 基于zepto的fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 判断微信客户端的那些坑 可以通过javascript直接调用原生分享的工具 JiaThis 分享到微信代码 聊聊移动端跨平台开发的各种技术 前端自动化测试 多种轮换图片 滑动侧边栏 13. 文件上传 百度上传组件 上传 flash 头像上传 图片上传预览 图片裁剪 图片裁剪-shearphoto jQuery图片处理 14. 模拟select 糖饼 select flexselect 双select select2 15. 取色插件 类似 Photoshop 的界面取色插件 jquery color 取色插件集合 farbtastic 圆环＋正方形 16. 城市联动 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 17. 剪贴板 剪贴板 clipboard 最新的剪切方案 18. 简繁转换 简繁转换 19. 表格 Grid facebook表格 类似于Excel编辑表格-handsontable bootstrap-table插件 datatables 20. 在线演示 js 在线编辑 - runjs js 在线编辑 - jsbin js 在线编辑 - codepen js 在线编辑 - jsfiddle java 在线编辑 - ideone js 在线编辑 - hcharts js 在线编辑 - jsdm sql 在线编辑 - sqlfiddle mozilla 在线编辑器 21. 播放器 Html5 VideoPlayer 22. 粒子动画 Proton 烟花 23. 表单验证 Validform formvalidator jQuery formValidator 五. Nodejs nodejs 篇幅比较巨大 Node.js 包教不包会 篇幅比较少 node express 入门教程 nodejs定时任务 一个nodejs博客 【NodeJS 学习笔记04】新闻发布系统 过年7天乐，学nodejs 也快乐 七天学会NodeJS Nodejs学习笔记（二）--- 事件模块 nodejs入门 angularjs nodejs 从零开始nodejs系列文章 理解nodejs nodejs事件轮询 node入门 nodejs cms Node初学者入门，一本全面的NodeJS教程 NodeJS的代码调试和性能调优 六. 性能优化 常规优化 Javascript高性能动画与页面渲染 移动H5前端性能优化指南 5173首页前端性能优化实践 给网页设计师和前端开发者看的前端性能优化 复杂应用的 CSS 性能分析和优化建议 张鑫旭——前端性能 前端性能监控总结 网站性能优化之CSS无图片技术 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 浏览器的加载与页面性能优化 页面加载中的图片性能优化 Hey——前端性能 html优化 99css——性能 Yslow——性能优化 YSLOW中文介绍 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 Yahoo!团队实践分享：网站性能 网站性能优化指南：什么使我们的网站变慢？ 网站性能优化实践，减少加载时间，提高用户体验 浅谈网站性能优化 前端篇 前端重构实践之如何对网站性能优化？ 前端性能优化：使用媒体查询加载指定大小的背景图片 网站性能系列博文 加载，不只是少一点点 前端性能的测试与优化 分享网页加载速度优化的一些技巧？ 页面加载中的图片性能优化 web前端优化(基于Yslow) 网站性能优化工具大全 【高性能前端1】高性能HTML 【高性能前端2】高性能CSS 由12306谈谈网站前端性能和后端性能优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 网站性能工具Yslow的使用方法 前端工程与性能优化（上）：静态资源版本更新与缓存 前端工程与性能优化（下）：静态资源管理与模板框架 HTTPS连接的前几毫秒发生了什么 Yslow Essential Web Performance Metrics — A Primer, Part 1 Essential Web Performance Metrics — Part 2 YUISlide,针对移动设备的动画性能优化 Improving Site Performance 让网站提速的最佳前端实践 Why Website Speed is Important Need for Speed – How to Improve your Website Performance 阿里无线前端性能优化指南 (Pt.1 加载期优化) 优化工具 JavaScript 性能分析新工具 OneProfile JavaScript 堆内存分析新工具 OneHeap 在线工具 google在线工具 阿里测 阿里-免费测试服务 阿里-F2etest多浏览器兼容性测试解决方案 js性能测试 轻松玩转PDF 七. 前端架构 技术架构 前端架构 如何成为前端架构师 关于前端架构-张克军 百度腾讯offer比较（腾讯游戏VS百度基础架构） &nbsp; 八. iconfont 中文字体 淘宝字库 字体 制作教程 zhangxinxu-icommon icommon 用字体在网页中画ICON图标(推荐教程) 字体压缩工具&nbsp;感谢初级群 [深圳-小鱼] 的推荐 九. 开发工具类 前端开发工具 IntelliJ IDEA 简体中文专题教程 Webstorm,InterllIdea,Phpstorm SublimeText Atom visual studio code Chrome, Firebug, Filddle 调试 Fiddler Fiddler调式使用知多少(一)深入研究 微信fiddle 微信fiddle Chrome Google Chrome 官方 Chrome - 基础 Chrome - 进阶 Chrome - 性能 Chrome - 性能进阶 Chrome - 移动 Chrome - 使用技巧 Chrome - Console控制台不完全指南 Chrome - Workspace使浏览器变成IDE network面板 chrome开发工具快捷键 chrome调试工具常用功能整理 Chrome 开发工具 Workspace 使用 Chrome神器Vimium快捷键学习记录 sass调试-w3cplus 如何更专业的使用Chrome开发者工具-w3cplus chrome调试canvas chrome profiles1 chrome profiles2 chrome profiles3 chrome移动版调试 chrome调试 chrome的调试 chrome console 命令详解 查看事件绑定1 查看事件绑定2 神器——Chrome开发者工具(一) 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍) chrome 开发者工具的 15 个小技巧 Chrome开发者工具不完全指南 Chrome 开发者工具使用技巧 Firebug firebug视频教程 firefox 模拟器 console.log 命令详解 Firebug入门指南 Firebug控制台详解 移动,微信调试 微信调试的那些事 微信调试官网 微信公众号本地调试 微信、手Q、Qzone之x5内核inspect调试解决方案 浏览器端调试安卓 移动端前端开发调试 使用 Chrome 远程调试 Android 设备 mac移动端调试 mac移动端调试 无线调试攻略 无线调试攻略 屌爆了,完美调试 微信webview(x5) 远程console 微信调试工具 各种真机远程调试方法汇总 手机测试自己写的web页面 iOS Simulator Simulator Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得 img loading img 智图-图片优化平台 在线png优化 生成二维码 生成二维码 浏览器同步 puer liveReload f5 File Watchers 在线PPT制作 nodePPT PPT reveal slippy 十. 前端导航网站 界面清爽的前端导航 前端导航 前端网址导航 前端名录 前端导航 前端开发资源 网址导航 前端开发仓库 - 众多效果的收集地 前端资源导航 F2E 前端导航 前端收藏夹 pFan 前端开发导航平台 十一. 常用CDN 新浪CDN 百度静态资源公共库 360网站卫士常用前端公共库CDN服务 Bootstrap中文网开源项目免费 CDN 服务 开放静态文件 CDN - 七牛 CDN加速 - jq22 jQuery CDN Google jQuery CDN 微软CDN 十二. Git,SVN,Github Git git-scm 廖雪峰-Git教程 git-for-windows GitHub 添加 SSH keys gogithub git常规命令练习 git的资料整理 我所记录的git命令（非常实用） 企业开发git工作流模式探索部分休整 GitHub 漫游指南 GitHub秘籍 使用git和github进行协同开发流程 动画方式练习git 版本管理工具介绍—Git篇 版本控制入门 – 搬进 Github Git动画演示 SVN 版本管理工具介绍---SVN篇","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"Vue|基于Vue的webGIS展示","date":"2020-04-27T05:27:00.000Z","path":"2020/04/27/Vue-基于Vue的webGIS展示/","text":"前言对之前那版的三维gis示例修改重构，使用vue+elementui集成。展示一些基础功能和拓展功能，部分拓展功能为开放。对每个示例加入一些基本操作，模型查看，场景调整等。 效果图1. 地图 2. 控件 数据 3. 三维效果 功能 4. 空间分析 数据可视化 5. 示例示例1 示例2 示例3 示例4 示例5 示例6 示例7 示例8 示例9 示例10 以前的版本：传送门","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"webGL|webgl2.0工作原理[转]","date":"2020-04-27T04:36:00.000Z","path":"2020/04/27/webGL-webgl2-0工作原理-转/","text":"WebGL2 工作原理看了这个文章会让你更知道怎么写 WebGL 代码而已。 原理细节远远不够， 更多的细节应该是看Opengl ，图形渲染管线， CPU与GPU通信， GPU流水线 。 WebGL 工作原理我们需要探讨一下WebGL在GPU上究竟做了什么。WebGL在GPU上的工作基本上分为两部分，第一部分是将顶点（或数据流）转换到裁剪空间坐标， 第二部分是基于第一部分的结果绘制像素点。 当你调用 gl.drawArrays(gl.TRIANGLE, 0, 9);这里的9表示“处理9个顶点”，所以将会有9个顶点被转换。 左侧是你提供的数据。顶点着色器（Vertex Shader）是你写进GLSL 中的一个方法，每个顶点调用一次，在这个方法中做一些数学运算后设置了一个特殊的gl_Position变量， 这个变量就是该顶点转换到裁剪空间中的坐标值，GPU接收该值并将其保存起来。 假设你正在画三角形，顶点着色器每完成三次顶点处理，WebGL就会用这三个顶点画一个三角形。它计算出这三个顶点对应的像素后，就会光栅化这个三角形，“光栅化”其实就是“用像素画出来” 的花哨叫法。对于每一个像素，它会调用你的片断着色器询问你使用什么颜色。你通过给片断着色器的一个特殊变量gl_FragColor设置一个颜色值，实现自定义像素颜色。 使用它们可以做出非常有趣的东西，但如你所见，到目前为止的例子中， 处理每个像素时片断着色器可用信息很少，幸运的是我们可以给它传递更多信息。想要从顶点着色器传值到片断着色器，我们可以定义“可变量（varyings）”。 一个简单的例子，将顶点着色器计算出的裁剪空间坐标从顶点着色器传递到片断着色器。 我们来画一个简单的三角形。 12345678910&#x2F;&#x2F; 定义一个三角形填充到缓冲里function setGeometry(gl) &#123;gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0, -100,150, 125,-175, 100]),gl.STATIC_DRAW);&#125; 我们只需要画三个顶点。 123456&#x2F;&#x2F; Draw the scene.function drawScene() &#123;...&#x2F;&#x2F; Draw the geometry.gl.drawArrays(gl.TRIANGLES, 0, 3);&#125; 然后在我们的顶点着色器中定义一个varying（可变量）用来给片断着色器传值。 1234567891011varying vec4 v_color;...void main() &#123;&#x2F;&#x2F; 将位置和矩阵相乘gl_Position &#x3D; vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1); &#x2F;&#x2F; 从裁减空间转换到颜色空间&#x2F;&#x2F; 裁减空间范围 -1.0 到 +1.0&#x2F;&#x2F; 颜色空间范围 0.0 到 1.0v_color &#x3D; gl_Position * 0.5 + 0.5;&#125; 在片断着色器中定义同名varying变量。 12345678#version 300 esprecision mediump float;in vec4 v_color;out vec4 outColor; void main() &#123;outColor &#x3D; v_color;&#125; WebGL会将同名的可变量从顶点着色器输入到片断着色器中。 下面是运行结果。 点此在新窗口中浏览 当你移动，缩放，旋转三角形时，发现颜色随位置变化，不跟着三角形移动。 回想一下，我们只计算了三个顶点，调用了三次顶点着色器，所以也只计算出了三个颜色值， 但是我们的三角形却有很多颜色，这就是称之为可变量的varying的原因啦！ WebGL先获得顶点着色器中计算的三个颜色值，在光栅化三角形时将会根据这三个值进行插值。每一个像素在调用片断着色器时，可变量的值是与之对应的插值。 让我们从上例的三个顶点开始分析 顶点0-100150125-175100 我们的给顶点着色器施加了一个包含平移，旋转和缩放的的矩阵，并将结果转换到裁剪空间。默认平移，旋转和缩放值为：平移 = 200, 150，旋转 = 0，缩放 = 1，所以这里只进行了平移。画布大小（背景缓冲）为 400×300，所以三个顶点在裁剪空间中为以下坐标值。 写入 gl_Position 的值0.0000.6600.750-0.830-0.875-0.660 同时将这些值转换到颜色空间中赋给我们定义的可变量v_color。 写入 v_color 的值0.50000.8300.50.87500.0860.50.06250.1700.5 利用这三个值进行插值后传进每个像素运行的片断着色器中。 v_color在v0，v1和v2之间插值 想要给片断着色器传值，我们可以先把值传递给顶点着色器然后再传给片断着色器。让我们来画一个由两个不同颜色三角形组成的矩形。我们需要给顶点着色器添加一个属性值， 把值通过属性传递给它后它再直接传递给片断着色器。 12345678910attribute vec2 a_position;attribute vec4 a_color;...varying vec4 v_color; void main() &#123;...&#x2F;&#x2F; 直接把属性值中的数据赋给可变量v_color &#x3D; a_color;&#125; 现在要给WebGL提供要用的颜色. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F; look up where the vertex data needs to go.var positionLocation &#x3D; gl.getAttribLocation(program, &quot;a_position&quot;);var colorLocation &#x3D; gl.getAttribLocation(program, &quot;a_color&quot;);...&#x2F;&#x2F; Create a buffer for the colors.var buffer &#x3D; gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER, buffer); &#x2F;&#x2F; Set the colors.setColors(gl); &#x2F;&#x2F; setup attributes...&#x2F;&#x2F; tell the color attribute how to pull data out of the current ARRAY_BUFFERgl.enableVertexAttribArray(colorLocation);var size &#x3D; 4;var type &#x3D; gl.FLOAT;var normalize &#x3D; false;var stride &#x3D; 0;var offset &#x3D; 0;gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset); ... &#x2F;&#x2F; Fill the buffer with colors for the 2 triangles&#x2F;&#x2F; that make the rectangle.function setColors(gl) &#123;&#x2F;&#x2F; Pick 2 random colors.var r1 &#x3D; Math.random();var b1 &#x3D; Math.random();var g1 &#x3D; Math.random(); var r2 &#x3D; Math.random();var b2 &#x3D; Math.random();var g2 &#x3D; Math.random(); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([ r1, b1, g1, 1,r1, b1, g1, 1,r1, b1, g1, 1,r2, b2, g2, 1,r2, b2, g2, 1,r2, b2, g2, 1]),gl.STATIC_DRAW);&#125; 这里是结果。 点此在新窗口中浏览 你可能注意到这两个三角形是纯色的。我们传递给每个三角形的顶点的颜色值是相同的， 所以我们传递的varying会被插值成相同的颜色，如果我们传递不同的颜色，就会看到插值的颜色。 123456789101112131415&#x2F;&#x2F; 给矩形的两个三角形&#x2F;&#x2F; 设置颜色值并发到缓冲function setColors(gl) &#123;&#x2F;&#x2F; 给每个顶点定义不同的颜色gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([ Math.random(), Math.random(), Math.random(), 1,Math.random(), Math.random(), Math.random(), 1,Math.random(), Math.random(), Math.random(), 1,Math.random(), Math.random(), Math.random(), 1,Math.random(), Math.random(), Math.random(), 1,Math.random(), Math.random(), Math.random(), 1]),gl.STATIC_DRAW);&#125; 现在看到的是插值的varying。 点此在新窗口中浏览 可能不值一提的是上例还演示了使用多个属性并且通过顶点着色器向片断着色器传值。如果你看了处理图片的例子， 那里面还用了另外一个属性传递纹理坐标。 关于buffer和attribute的代码是干什么的？ 缓冲操作是在GPU上获取顶点和其他顶点数据的一种方式。gl.createBuffer创建一个缓冲；gl.bindBuffer是设置缓冲为当前使用缓冲；gl.bufferData将数据拷贝到缓冲，这个操作一般在初始化完成。 一旦数据存到缓冲中，还需要告诉WebGL怎么从缓冲中提取数据传给顶点着色器的属性。 要做这些，首先需要获取WebGL给属性分配的地址，如下方代码所示 123&#x2F;&#x2F; 询问顶点数据应该放在哪里var positionLocation &#x3D; gl.getAttribLocation(program, &quot;a_position&quot;);var colorLocation &#x3D; gl.getAttribLocation(program, &quot;a_color&quot;); 这一步一般也是在初始化部分完成。 一旦知道了属性的地址，在绘制前还需要发出三个命令。 gl.enableVertexAttribArray(location);这个命令是告诉WebGL我们想从缓冲中提供数据。 gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);这个命令是将缓冲绑定到 ARRAY_BUFFER 绑定点，它是WebGL内部的一个全局变量。 1234567gl.vertexAttribPointer(location,numComponents,typeOfData,normalizeFlag,strideToNextPieceOfData,offsetIntoBuffer); 这个命令告诉WebGL从 ARRAY_BUFFER绑定点当前绑定的缓冲获取数据。每个顶点有几个单位的数据(1 - 4)，单位数据类型是什么(BYTE, FLOAT, INT, UNSIGNED_SHORT, 等等…)， stride 是从一个数据到下一个数据要跳过多少位，最后是数据在缓冲的什么位置。 单位个数永远是 1 到 4 之间。 如果每个类型的数据都用一个缓冲存储，stride 和 offset 都是 0 。对 stride 来说 0 表示 “用符合单位类型和单位个数的大小”。对 offset 来说 0 表示从缓冲起始位置开始读取。它们使用 0 以外的值时会复杂得多，虽然这样会取得一些性能能上的优势， 但是一般情况下并不值得，除非你想充分压榨WebGL的性能。 希望这些关于缓冲和属性的内容对你来说讲的足够清楚。 vertexAttribPointer 中的 normalizeFlag 参数是什么意思？ 标准化标记（normalizeFlag）适用于所有非浮点型数据。如果传递false就解读原数据类型。BYTE 类型的范围是从 -128 到 127，UNSIGNED_BYTE 类型的范围是从 0 到 255， SHORT 类型的范围是从 -32768 到 32767，等等… 如果标准化标记设为true，BYTE 数据的值(-128 to 127)将会转换到 -1.0 到 +1.0 之间， UNSIGNED_BYTE (0 to 255) 变为 0.0 到 +1.0 之间，SHORT 也是转换到 -1.0 到 +1.0 之间， 但比 BYTE 精确度高。 最常用的是标准化颜色数据。大多数情况颜色值范围为 0.0 到 +1.0。使用4个浮点型数据存储红，绿，蓝和阿尔法通道数据时，每个顶点的颜色将会占用16字节空间， 如果你有复杂的几何体将会占用很多内存。代替的做法是将颜色数据转换为四个 UNSIGNED_BYTE ， 其中 0 表示 0.0，255 表示 1.0。现在每个顶点只需要四个字节存储颜色值，省了 75% 空间。 我们来修改之前代码实现。当我们告诉WebGL如何获取颜色数据时将这样 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; 告诉颜色属性如何从colorBuffer中提取数据 (ARRAY_BUFFER)var size &#x3D; 4; &#x2F;&#x2F; 每次迭代使用四个单位数据var type &#x3D; gl.UNSIGNED_BYTE; &#x2F;&#x2F; 数据类型是8位的 UNSIGNED_BYTE 类型。var normalize &#x3D; true; &#x2F;&#x2F; 标准化数据var stride &#x3D; 0; &#x2F;&#x2F; 0 &#x3D; 移动距离 * 单位距离长度sizeof(type)&#x2F;&#x2F; 每次迭代跳多少距离到下一个数据var offset &#x3D; 0; &#x2F;&#x2F; 从缓冲的起始处开始gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset)如下向缓冲添加数据&#x2F;&#x2F; 给矩形的两个三角形&#x2F;&#x2F; 设置颜色值并发到缓冲function setColors(gl) &#123;&#x2F;&#x2F; 设置两个随机颜色var r1 &#x3D; Math.random() * 256; &#x2F;&#x2F; 0 到 255.99999 之间var b1 &#x3D; Math.random() * 256; &#x2F;&#x2F; 这些数据var g1 &#x3D; Math.random() * 256; &#x2F;&#x2F; 在存入缓冲时var r2 &#x3D; Math.random() * 256; &#x2F;&#x2F; 将被截取成var b2 &#x3D; Math.random() * 256; &#x2F;&#x2F; Uint8Array 类型var g2 &#x3D; Math.random() * 256; gl.bufferData(gl.ARRAY_BUFFER,new Uint8Array( &#x2F;&#x2F; Uint8Array[ r1, b1, g1, 255,r1, b1, g1, 255,r1, b1, g1, 255,r2, b2, g2, 255,r2, b2, g2, 255,r2, b2, g2, 255]),gl.STATIC_DRAW);&#125; 这里是结果。","tags":[{"name":"WebGL","slug":"WebGL","permalink":"http://yoursite.com/tags/WebGL/"}]},{"title":"cesium|源码跟读 - cesium的数据调度渲染过程","date":"2020-04-25T15:41:00.000Z","path":"2020/04/25/cesium-源码跟读-数据调度/","text":"前言学习源码的时候有一个好的学习方案往往能事半功倍。 在跟读源码时定下一个学习目标，记录学习过程。 比如需要了解那个API的初始化过程来作为学习导向。 这篇已cesium如何渲染地形和影像为学习导向来研究cesium的数据调度机制 数据调度之前讲过cesiumWidget如何初始化的，里边说到场景内的数据会自动做每一帧的循环渲染。 startRenderLoop 开始渲染三维窗口内的对象 通过requestAnimationFrame函数循环渲染，每一帧的结束，就是下一帧的开始 使用requestAnimationFrame创建一个draw循环 每个动画帧都调用tick回调函数 最终都会都用scene.render()函数 其中 地形和影像 都是在globe.beginframe 和 globe.endframe之间完成渲染的 调度说明updateAndExecuteCommands 负责数据的调度，比如哪些Tile需要创建，这些Tile相关的地形数据，以及涉及到的影像数据之间的调度，都是在该函数中维护。但是updateAndExecuteCommands函数只负责管理，也就是他所创建的Tile类只是一个个的Tasks，自己并不负责Tasks内容的实现（数据的加载和维护）。这样，导致架构会有些复杂，因为不是一个流水线的作业方式，所以就需要有状态的维护。但这也是必然的，不仅保证该函数高效，不拖累每一帧的时间消耗，同时因为实时性满足人的要求（帧数能够达到或接近60），每一帧需要的Tile队列可以实时计算，不用考虑时间和状态之间的关系。 可以这样理解，updateAndExecuteCommands是一个管理者，只说不做，与之相反，scene.globe.endFrame中，会对该帧所涉及的GlobeTile的下载，解析等进行处理 简单而言，updateAndExecuteCommands负责上面看得见的事情，根据当前这一帧相机的状态，先打一个黄色的网格，然后检查当前状态下，这些网格里面的地形和影像数据是否都已经准备好了，如果准备好，每一个Tile就创建一个DrawCommand来渲染，把这个球画出来。如果没准备好也不管，反正有endFrame函数负责，各司其职 scene.globe.endFrame就按照吩咐来准备每一个Tile的数据，全是看不见的工作，默默的奉献自己的青春。这里，Promise，Worker等技术都会使用，通过异步和多线程的方式，来缓解每一帧的负担，而在主线程下，主要是数据状态的维护。如果一个Tile的数据解析完成，则该GlobeTile的状态更新为renderable（可渲染），done（已完成）。 类关系图 在这个过程中，类的关系大致如下： 网格按照经纬度来划分的，每一个网格对应一个QuadtreeTile四叉树类，其中有一个GlobeSurfaceTile，里面保存地形数据TileTerrain和影像数据TileImagery。当前相机下需要多个网格，就需要多个QuadtreeTile，该队列保存在QuadtreePrimitive，QuadtreePrimitive统一维护所有Tile的管理，具体是通过GlobeSurfaceTileProvider来实现逻辑操作，而QuadtreePrimitive上面包了一个Globe和Scene 初始化globe 创建QuadtreePrimitive数据队列对象， 该对象会实例化 一个GlobeSurfaceTileProvider将地形和影像数据分别存储进去 渲染过程 地形和影像的渲染是通过updateAndExecuteCommands完成数据调度 关系图 源码跟读 scene.updateAndExecuteCommands 开始执行 scene.executeCommandsInViewport 方法 执行 updateAndRenderPrimitives 调用globe的update函数 globe.update调用数据队列的update 最终调用GlobeSurfaceTileProvider 实现逻辑 渲染说明 在QuadtreePrimitive的update中，调用selectTilesForRendering来或许当前需要创建的网格，其中，在第一帧会把全球分为两块Tile： 而在queueChildrenLoadAndDetermineIfChildrenAreAllRenderable函数中，基于这两个Tile来做四叉树剖分，也就是所有的后来的QuadtreeTile都能够上溯到这两个Tile之一： 创建的GlobeSurfaceTile都会存储到更新队列中，等待数据下载和解析的过程，而如果当前帧中，存在准备好的，已经可以渲染的GlobeSurfaceTile，则调用addDrawCommandsForTile，构造成VBO，最终通过WebGL实现渲染。 更新过程 用大佬的原文解释: 参考博文 : https://www.cnblogs.com/fuckgiser/p/5744509.html","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|源码跟读 - CesiumWidget","date":"2020-04-25T15:05:00.000Z","path":"2020/04/25/cesium-源码跟读-CesiumWidget/","text":"CesiumWidget三维窗口对象 cesium的核心Api 通过实例化CesiumWidget 创建cesium容器和canvas画布 渲染三维场景和管理场景控件等 结构图 初始化流程实例化CesiumWidget 流程 获取cesium页面容器，挂载三维窗口widget对象，创建canvas画布对象初始化信用容器innerCreditContainer挂载到页面 实例化窗口部件，初始化场景和配置场景内的参数。添加场景屏幕事件 设置是否循环渲染，cesium中数据渲染会按批次进行每一帧的渲染 默认渲染，通过requestAnimationFrame函数进行循环渲染场景，每次结束都会调用scene.render() 初始化场景内的组件globe，SkyBox，Sun，Moon 基本属性和方法函数 主要函数render 渲染场景。该功能会自动调用除非 useDefaultRenderLoop 设置为false； resize 更新画布大小，相机纵横比和视口大小。除非需要，否则将自动调用此函数 useDefaultRenderLoop 设置为false。 destroy 销毁小部件。如果被永久调用从布局中删除小部件。 showErrorPanel 向用户显示错误面板，其中包含标题和较长的错误消息，可以使用’确定’按钮将其关闭。该面板自动显示发生渲染循环错误时，如果showRenderLoopErrors不为false，则当小部件已构建 说明官网案例使用的都是Cesium.Viewer这个窗体组件，包含了非常丰富的组件内容。Cesium.CesiumWidget可以说是其简化版本，不包含动画、图层选择等等其他组件内容，仅仅显示一个三维数字地球。并且，默认情况下也不会包含Cesium地形的图层。 创建一个纯净的地球 new Cesium.CesiumWidget(&#39;cesiumContainer&#39;);","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|视线分析(环视，通视)","date":"2020-04-20T08:28:00.000Z","path":"2020/04/20/cesium-环视分析/","text":"通视分析 检测观察点是否可视，设置起终点创建射线，通过求交函数pickFromRay计算与一段射线相交的碰撞点并返回相交点。最后绘制相交位置点，以此为分析点绘制通视线 环视分析（3dtileset） 通过绘制椭圆计算椭圆边的位置点，通过中心点和边界点计算线段差值。将计算的差值点数组与场景范围内的3dtileset数据，使用clampToHeightMostDetailed查询每个位置点与当前场景内的3dtileset的clipToHeight夹紧位置，通过线段差值计算相邻的两点高度是否递增 部分实现射线求交实现 12345678910111213141516171819202122232425&#x2F;** * 获取相交对象 * @param &#123;*&#125; startPos * @param &#123;*&#125; endPos * @param &#123;*&#125; excludeArr * @param &#123;*&#125; bDrillPick *&#x2F; _getIntersectObj(startPos, endPos, excludeArr &#x3D; [], bDrillPick &#x3D; false) &#123; var viewer &#x3D; this._viewer; var direction &#x3D; Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(endPos, startPos, new Cesium.Cartesian3()), new Cesium.Cartesian3()); var ray &#x3D; new Cesium.Ray(startPos, direction); &#x2F;&#x2F;无限延长的射线 var results &#x3D; []; if (bDrillPick) &#123; results &#x3D; viewer.scene.drillPickFromRay(ray, 10, excludeArr); &#125; else &#x2F;&#x2F;只pick首个物体 &#123; var result &#x3D; viewer.scene.pickFromRay(ray, excludeArr); if (Cesium.defined(result)) &#123; results &#x3D; [result]; &#125; &#125; return results; &#125;","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|挖地形，地形坡度和模拟地形淹没","date":"2020-04-20T06:27:00.000Z","path":"2020/04/20/sium-挖地形和模拟地形淹没/","text":"效果挖地形 通过绘制多边形获取边界点集合，把边界点分别计算生成多个ClippingPlane面 ，用ClippingPlaneCollection接口生成裁剪地形效果。最后分别将侧边和底部加上贴图效果 淹没分析 通过绘制多边形获取边界点集合，用extrudedHeight属性动态控制淹没高度，简单模拟淹没效果。熟悉webgl的可以通过修改shader的顶点和片段着色器创建淹没效果 坡度分析(地形)通过绘制多段线获取线段点集合，用lerp获取点的线性插值结果，将返回的差值点高程绘制出来，实现坡度图 说明挖地形插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241import Cesium from &#39;..&#x2F;namespace&#39;function TerrainClipPlan(t, i) &#123; this.viewer &#x3D; t, this.options &#x3D; i || &#123;&#125;, this._positions &#x3D; i.positions, this._height &#x3D; this.options.height || 0, this.bottomImg &#x3D; i.bottomImg, this.wallImg &#x3D; i.wallImg, this.splitNum &#x3D; Cesium.defaultValue(i.splitNum, 50), this._positions &amp;&amp; this._positions.length &gt; 0 &amp;&amp; this.updateData(this._positions)&#125;Object.defineProperties(TerrainClipPlan.prototype, &#123; show: &#123; get: function () &#123; return this._show &#125;, set: function (e) &#123; this._show &#x3D; e, this.viewer.scene.globe.clippingPlanes &amp;&amp; (this.viewer.scene.globe.clippingPlanes.enabled &#x3D; e), this._switchExcavate(e) &#125; &#125;, height: &#123; get: function () &#123; return this._height &#125;, set: function (e) &#123; this._height &#x3D; e, this._updateExcavateDepth(e) &#125; &#125;&#125;)TerrainClipPlan.prototype.updateData &#x3D; function (e) &#123; this.clear(); var t &#x3D; [], i &#x3D; e.length, a &#x3D; new Cesium.Cartesian3, n &#x3D; Cesium.Cartesian3.subtract(e[0], e[1], a); n &#x3D; n.x &gt; 0, this.excavateMinHeight &#x3D; 9999; for (var r &#x3D; 0; r &lt; i; ++r) &#123; var s &#x3D; (r + 1) % i, l &#x3D; Cesium.Cartesian3.midpoint(e[r], e[s], new Cesium.Cartesian3), u &#x3D; Cesium.Cartographic.fromCartesian(e[r]), c &#x3D; this.viewer.scene.globe.getHeight(u) || u.height; c &lt; this.excavateMinHeight &amp;&amp; (this.excavateMinHeight &#x3D; c); var d, h &#x3D; Cesium.Cartesian3.normalize(l, new Cesium.Cartesian3); d &#x3D; n ? Cesium.Cartesian3.subtract(e[r], l, new Cesium.Cartesian3) : Cesium.Cartesian3.subtract(e[s], l, new Cesium.Cartesian3), d &#x3D; Cesium.Cartesian3.normalize(d, d); var f &#x3D; Cesium.Cartesian3.cross(d, h, new Cesium.Cartesian3); f &#x3D; Cesium.Cartesian3.normalize(f, f); var p &#x3D; new Cesium.Plane(f, 0), m &#x3D; Cesium.Plane.getPointDistance(p, l); t.push(new Cesium.ClippingPlane(f, m)) &#125; this.viewer.scene.globe.clippingPlanes &#x3D; new Cesium.ClippingPlaneCollection(&#123; planes: t, edgeWidth: 1, edgeColor: Cesium.Color.WHITE, enabled: !0 &#125;), this._prepareWell(e), this._createWell(this.wellData)&#125;TerrainClipPlan.prototype.clear &#x3D; function () &#123; this.viewer.scene.globe.clippingPlanes &amp;&amp; (this.viewer.scene.globe.clippingPlanes.enabled &#x3D; !1, this.viewer.scene.globe.clippingPlanes.removeAll(), this.viewer.scene.globe.clippingPlanes.isDestroyed() || this.viewer.scene.globe.clippingPlanes.destroy()), this.viewer.scene.globe.clippingPlanes &#x3D; void 0, this.bottomSurface &amp;&amp; this.viewer.scene.primitives.remove(this.bottomSurface), this.wellWall &amp;&amp; this.viewer.scene.primitives.remove(this.wellWall), delete this.bottomSurface, delete this.wellWall, this.viewer.scene.render()&#125;TerrainClipPlan.prototype._prepareWell &#x3D; function (e) &#123; var t &#x3D; this.splitNum, i &#x3D; e.length; if (0 !&#x3D; i) &#123; for (var a &#x3D; this.excavateMinHeight - this.height, n &#x3D; [], r &#x3D; [], s &#x3D; [], l &#x3D; 0; l &lt; i; l++) &#123; var u &#x3D; l &#x3D;&#x3D; i - 1 ? 0 : l + 1, c &#x3D; Cesium.Cartographic.fromCartesian(e[l]), d &#x3D; Cesium.Cartographic.fromCartesian(e[u]), h &#x3D; [c.longitude, c.latitude], f &#x3D; [d.longitude, d.latitude]; 0 &#x3D;&#x3D; l &amp;&amp; ( s.push(new Cesium.Cartographic(h[0], h[1])), r.push(Cesium.Cartesian3.fromRadians(h[0], h[1], a)), n.push(Cesium.Cartesian3.fromRadians(h[0], h[1], 0))); for (var p &#x3D; 1; p &lt;&#x3D; t; p++) &#123; var m &#x3D; Cesium.Math.lerp(h[0], f[0], p &#x2F; t), g &#x3D; Cesium.Math.lerp(h[1], f[1], p &#x2F; t); l &#x3D;&#x3D; i - 1 &amp;&amp; p &#x3D;&#x3D; t || ( s.push(new Cesium.Cartographic(m, g)), r.push(Cesium.Cartesian3.fromRadians(m, g, a)), n.push(Cesium.Cartesian3.fromRadians(m, g, 0))) &#125; &#125; this.wellData &#x3D; &#123; lerp_pos: s, bottom_pos: r, no_height_top: n &#125; &#125;&#125;TerrainClipPlan.prototype._createWell &#x3D; function (e) &#123; if (Boolean(this.viewer.terrainProvider._layers)) &#123; var t &#x3D; this; this._createBottomSurface(e.bottom_pos); var i &#x3D; Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, e.lerp_pos); Cesium.when(i, function (i) &#123; for (var a &#x3D; i.length, n &#x3D; [], r &#x3D; 0; r &lt; a; r++) &#123; var s &#x3D; Cesium.Cartesian3.fromRadians(i[r].longitude, i[r].latitude, i[r].height); n.push(s) &#125; t._createWellWall(e.bottom_pos, n) &#125;) &#125; else &#123; this._createBottomSurface(e.bottom_pos); this._createWellWall(e.bottom_pos, e.no_height_top) &#125;&#125;TerrainClipPlan.prototype._getMinHeight &#x3D; function (e) &#123; let minHeight &#x3D; 5000000; let minPoint &#x3D; null; for (let i &#x3D; 0; i &lt; e.length; i++) &#123; let height &#x3D; e[i][&#39;z&#39;]; if (height &lt; minHeight) &#123; minHeight &#x3D; height; minPoint &#x3D; this._ellipsoidToLonLat(e[i]); &#125; &#125; return minPoint.altitude;&#125;TerrainClipPlan.prototype._ellipsoidToLonLat &#x3D; function (c) &#123; let ellipsoid &#x3D; this.viewer.scene.globe.ellipsoid; let cartesian3 &#x3D; new Cesium.Cartesian3(c.x, c.y, c.z); let cartographic &#x3D; ellipsoid.cartesianToCartographic(cartesian3); let lat &#x3D; Cesium.Math.toDegrees(cartographic.latitude); let lng &#x3D; Cesium.Math.toDegrees(cartographic.longitude); let alt &#x3D; cartographic.height; return &#123; longitude: lng, latitude: lat, altitude: alt &#125;&#125;TerrainClipPlan.prototype._createBottomSurface &#x3D; function (e) &#123; if (e.length) &#123; let minHeight &#x3D; this._getMinHeight(e); let positions &#x3D; []; for (let i &#x3D; 0; i &lt; e.length; i++) &#123; let p &#x3D; this._ellipsoidToLonLat(e[i]); positions.push(p.longitude); positions.push(p.latitude); positions.push(minHeight); &#125; let polygon &#x3D; new Cesium.PolygonGeometry(&#123; polygonHierarchy: new Cesium.PolygonHierarchy( Cesium.Cartesian3.fromDegreesArrayHeights(positions) ), perPositionHeight: true &#125;); let geometry &#x3D; Cesium.PolygonGeometry.createGeometry(polygon); var i &#x3D; new Cesium.Material(&#123; fabric: &#123; type: &quot;Image&quot;, uniforms: &#123; image: this.bottomImg &#125; &#125; &#125;), a &#x3D; new Cesium.MaterialAppearance(&#123; translucent: !1, flat: !0, material: i &#125;); this.bottomSurface &#x3D; new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: geometry &#125;), appearance: a, asynchronous: !1 &#125;), this.viewer.scene.primitives.add(this.bottomSurface) &#125;&#125;TerrainClipPlan.prototype._createWellWall &#x3D; function (e, t) &#123; let minHeight &#x3D; this._getMinHeight(e); let maxHeights &#x3D; []; let minHeights &#x3D; []; for (let i &#x3D; 0; i &lt; t.length; i++) &#123; maxHeights.push(this._ellipsoidToLonLat(t[i]).altitude); minHeights.push(minHeight); &#125; let wall &#x3D; new Cesium.WallGeometry(&#123; positions: t, maximumHeights: maxHeights, minimumHeights: minHeights, &#125;); let geometry &#x3D; Cesium.WallGeometry.createGeometry(wall); var a &#x3D; new Cesium.Material(&#123; fabric: &#123; type: &quot;Image&quot;, uniforms: &#123; image: this.wallImg &#125; &#125; &#125;), n &#x3D; new Cesium.MaterialAppearance(&#123; translucent: !1, flat: !0, material: a &#125;); this.wellWall &#x3D; new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: geometry, attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY) &#125;, id: &quot;PitWall&quot; &#125;), appearance: n, asynchronous: !1 &#125;), this.viewer.scene.primitives.add(this.wellWall)&#125;TerrainClipPlan.prototype._switchExcavate &#x3D; function (e) &#123; e ? (this.viewer.scene.globe.material &#x3D; Cesium.Material.fromType(&quot;WaJue&quot;), this.wellWall.show &#x3D; !0, this.bottomSurface.show &#x3D; !0) : (this.viewer.scene.globe.material &#x3D; null, this.wellWall.show &#x3D; !1, this.bottomSurface.show &#x3D; !1)&#125;TerrainClipPlan.prototype._updateExcavateDepth &#x3D; function (e) &#123; this.bottomSurface &amp;&amp; this.viewer.scene.primitives.remove(this.bottomSurface), this.wellWall &amp;&amp; this.viewer.scene.primitives.remove(this.wellWall); for (var t &#x3D; this.wellData.lerp_pos, i &#x3D; [], a &#x3D; t.length, n &#x3D; 0; n &lt; a; n++) i.push(Cesium.Cartesian3.fromRadians(t[n].longitude, t[n].latitude, this.excavateMinHeight - e)); this.wellData.bottom_pos &#x3D; i, this._createWell(this.wellData), this.viewer.scene.primitives.add(this.bottomSurface), this.viewer.scene.primitives.add(this.wellWall)&#125;export default TerrainClipPlan 调用 123456789let terrainClipPlan &#x3D; new TerrainClipPlan(this._viewer._delegate, &#123; height: this._height, splitNum: this._splitNum, wallImg: this._wallImg, bottomImg: this._bottomImg &#125;) console.log(this._hierarchy.positions) terrainClipPlan.updateData(this._hierarchy.positions)","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|三角量测","date":"2020-04-16T12:40:00.000Z","path":"2020/04/16/cesium-量测工具/","text":"效果三角量测 面积量测 线段距离 还有一个圆形面量测 实现量测是地图工具中比较基础的功能，实现也比较容易。三角量测稍微需要研究一点，这里提供思路：1.动态创建三条线段 2.通过直线两端的点计算水平线的另一端坐标 3.动态计算距离并表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&#x2F;** * 三角测量 *&#x2F;class MeasureTriangles extends Draw &#123; constructor(measureInfo, style) &#123; super(measureInfo) this._tempLineEntity &#x3D; new Cesium.Entity() this._tempLineEntity2 &#x3D; new Cesium.Entity() this._positions &#x3D; [] this._tempPoints &#x3D; [] this._tempPoints2 &#x3D; [] this._style &#x3D; &#123; ...DEF_STYLE, ...style &#125; &#125; _mouseClickHandler(movement) &#123; &#x2F;&#x2F;let position &#x3D; this._viewer.delegate.scene.camera.pickEllipsoid(movement.position, Cesium.Ellipsoid.WGS84) let position &#x3D; this._viewer.scene.pickPosition(movement.position); if(!position)return false if (this._positions.length &#x3D;&#x3D; 0) &#123; this._positions.push(position.clone()) this._positions.push(position.clone()) this._tempPoints.push(position.clone()) this._tempPoints.push(position.clone()) &#125; &#125; _mouseMoveHandler(movement) &#123; this._viewer.tooltip.setContent(&#39;单击选择点位,双击结束&#39;) &#x2F;&#x2F;let position &#x3D; this._viewer.delegate.scene.camera.pickEllipsoid(movement.endPosition, Cesium.Ellipsoid.WGS84) let position &#x3D; this._viewer.scene.pickPosition(movement.endPosition); this._viewer.tooltip.setPosition(position) if (position &amp;&amp; this._positions.length &gt; 0) &#123; &#x2F;&#x2F;直线 this._positions.pop() this._positions.push(position.clone()); let horizontalPosition &#x3D; this._computesHorizontalLine(this._positions) &#x2F;&#x2F;高度 this._tempPoints.pop() this._tempPoints.push(horizontalPosition.clone()) &#x2F;&#x2F;水平线 this._tempPoints2.pop(),this._tempPoints2.pop() this._tempPoints2.push(position.clone()) this._tempPoints2.push(horizontalPosition.clone()) &#125; &#125; _getHeading(startPosition, endPosition)&#123; if(!startPosition &amp;&amp; !endPosition )return 0 if(Cesium.Cartesian3.equals(startPosition, endPosition))return 0 let cartographic &#x3D; Cesium.Cartographic.fromCartesian(startPosition); let cartographic2 &#x3D; Cesium.Cartographic.fromCartesian(endPosition); return (cartographic2.height - cartographic.height).toFixed(2) &#125; _computesHorizontalLine(positions)&#123; let cartographic &#x3D; Cesium.Cartographic.fromCartesian(positions[0]); let cartographic2 &#x3D; Cesium.Cartographic.fromCartesian(positions[1]); return Cesium.Cartesian3.fromDegrees( Cesium.Math.toDegrees(cartographic.longitude), Cesium.Math.toDegrees(cartographic.latitude), cartographic2.height ) &#125; _mouseDbClickHandler(movement) &#123; this._unbindEnvet() this._measureEvent.raiseEvent(&#123; type: &#39;triangles&#39;, points: [this._positions,this._tempPoints,this._tempPoints2]&#125;) &#125; _prepareDelegate() &#123; &#x2F;&#x2F;直线 this._delegate.polyline &#x3D; &#123; positions: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._positions &#125;, false), ...this._style &#125; this._delegate.position &#x3D; new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._positions[0] &#125;, false), this._delegate.point &#x3D; &#123; pixelSize: 5, outlineColor: Cesium.Color.BLUE, outlineWidth: 5 &#125; this._delegate.label &#x3D; &#123; text: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return &#39;直线:&#39; + CV.Math.getDistance(CV.T.transformCartesianArrayToWSG84Array(this._positions)) + &#39;米&#39; &#125;, false), show: true, showBackground: true, font: &#39;14px monospace&#39;, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(50, -100) &#x2F;&#x2F;left top &#125; &#x2F;&#x2F;高度 this._tempLineEntity.polyline &#x3D; &#123; positions: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._tempPoints &#125;, false), ...this._style &#125; this._tempLineEntity.position &#x3D; new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._tempPoints2[1] &#125;, false), this._tempLineEntity.point &#x3D; &#123; pixelSize: 5, outlineColor: Cesium.Color.BLUE, outlineWidth: 5 &#125; this._tempLineEntity.label &#x3D; &#123; text: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return &#39;高度:&#39; + this._getHeading(this._tempPoints[0],this._tempPoints[1]) + &#39;米&#39; &#125;, false), show: true, showBackground: true, font: &#39;14px monospace&#39;, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(-20, 100) &#x2F;&#x2F;left top &#125; &#x2F;&#x2F;水平 this._tempLineEntity2.polyline &#x3D; &#123; positions: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._tempPoints2 &#125;, false), ...this._style &#125; this._tempLineEntity2.position &#x3D; new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return this._positions[1] &#125;, false), this._tempLineEntity2.point &#x3D; &#123; pixelSize: 5, outlineColor: Cesium.Color.BLUE, outlineWidth: 5 &#125; this._tempLineEntity2.label &#x3D; &#123; text: new Cesium.CallbackProperty(time &#x3D;&gt; &#123; return &#39;水平距离:&#39; + CV.Math.getDistance(CV.T.transformCartesianArrayToWSG84Array(this._tempPoints2)) + &#39;米&#39; &#125;, false), show: true, showBackground: true, font: &#39;14px monospace&#39;, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(-150, -20) &#x2F;&#x2F;left top &#125; this._layer.entities.add(this._tempLineEntity2) this._layer.entities.add(this._tempLineEntity) this._layer.entities.add(this._delegate) &#125;&#125;export default MeasureTriangles","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium | 可视域分析 2","date":"2020-04-15T10:04:00.000Z","path":"2020/04/15/cesium-可视域分析-2/","text":"效果在之前的可视域分析升级了一下 ~ 可以支持动态修改 实现这里重新写了一个Primitive 需要修改ShadowMapShader.js 123456789fsSource +&#x3D; &#39; if(visibility&gt;0.5) \\n&#39; + &#39; &#123; \\n&#39; + &#39; gl_FragColor &#x3D; vec4(&#39; + visiblyColor.red + &#39;,&#39; + visiblyColor.green + &#39;,&#39; + visiblyColor.blue + &#39;,&#39; + visiblyColor.alpha + &#39;); \\n&#39; + &#39; &#125; \\n&#39; + &#39; else&#123; \\n&#39; + &#39; gl_FragColor &#x3D; vec4(&#39; + invisiblyColor.red + &#39;,&#39; + invisiblyColor.green + &#39;,&#39; + invisiblyColor.blue + &#39;,&#39; + invisiblyColor.alpha + &#39;); \\n&#39; + &#39; &#125; \\n&#39; + &#39;&#125; \\n&#39;;","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|三维可视化展示","date":"2020-04-12T07:24:00.000Z","path":"2020/04/12/cESIU/","text":"前言因工作需要学习cesium有一段时间了，对现有的业务功能进行模块化封装和效果展示。封装完成之后开发一套前端模版，以后项目基本可以基于这个平台做二次开发； 效果展示分为基础功能展示，分析可视化，以及业务功能模块展示 场景控制，地图工具 可视化组件 开源插件 图形插件 控件 地球控制 分析功能 业务封装 ~演示地址私信 前端模版基于封装的sdk的开发模版 集成开源插件，场景控制等 内置8种皮肤 可视域分析 通视分析 环视分析 淹没分析 挖地分析 坡度分析(地形) 基础量测 平台正在完善…","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|传感器效果插件","date":"2020-04-12T06:59:00.000Z","path":"2020/04/12/cesium-传感器动画扫描czml/","text":"效果效果1 矩形传感器 效果2 圆锥传感器 基于czml的动画展示 示例1234567891011121314151617181920212223242526define(function(require) &#123; &#39;use strict&#39;; var initialize &#x3D; require(&#39;.&#x2F;initialize&#39;); var ConicSensorGraphics &#x3D; require(&#39;.&#x2F;conic&#x2F;conic-sensor-graphics&#39;); var ConicSensorVisualizer &#x3D; require(&#39;.&#x2F;conic&#x2F;conic-sensor-visualizer&#39;); var CustomPatternSensorGraphics &#x3D; require(&#39;.&#x2F;custom&#x2F;custom-pattern-sensor-graphics&#39;); var CustomPatternSensorVisualizer &#x3D; require(&#39;.&#x2F;custom&#x2F;custom-pattern-sensor-visualizer&#39;); var CustomSensorVolume &#x3D; require(&#39;.&#x2F;custom&#x2F;custom-sensor-volume&#39;); var RectangularPyramidSensorVolume &#x3D; require(&#39;.&#x2F;rectangular&#x2F;rectangular-pyramid-sensor-volume&#39;); var RectangularSensorGraphics &#x3D; require(&#39;.&#x2F;rectangular&#x2F;rectangular-sensor-graphics&#39;); var RectangularSensorVisualizer &#x3D; require(&#39;.&#x2F;rectangular&#x2F;rectangular-sensor-visualizer&#39;); initialize(); return &#123; ConicSensorGraphics: ConicSensorGraphics, ConicSensorVisualizer: ConicSensorVisualizer, CustomPatternSensorGraphics: CustomPatternSensorGraphics, CustomPatternSensorVisualizer: CustomPatternSensorVisualizer, CustomSensorVolume: CustomSensorVolume, RectangularPyramidSensorVolume: RectangularPyramidSensorVolume, RectangularSensorGraphics: RectangularSensorGraphics, RectangularSensorVisualizer: RectangularSensorVisualizer &#125;;&#125;); 开源地址:github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium| Primitive图元自定义着色器(2)","date":"2020-04-12T06:31:00.000Z","path":"2020/04/12/cesium-Primitive图元自定义着色器-1/","text":"效果动态雷达传感器 攻击线 动态扩散点 示例动态雷达传感器开源插件，推荐使用时直接升级添加到项目中 12345678910111213141516171819202122232425262728293031323334import Cesium from &quot;Cesium&quot;;import &#123;RectangularSensorPrimitive&#125; from &quot;.&#x2F;RectangularSensor&#x2F;RectangularSensorPrimitive&quot;;import &#123;RectangularSensorGraphics&#125; from &quot;.&#x2F;RectangularSensor&#x2F;RectangularSensorGraphics&quot;;import &#123;RectangularSensorVisualizer&#125; from &#39;.&#x2F;RectangularSensor&#x2F;RectangularSensorVisualizer&#39;;&#x2F;&#x2F;conicSensorimport &#123;ConicArcSensorGeometry&#125; from &#39;.&#x2F;ConicArcSensor&#x2F;ConicArcSensorGeometry&#39;;import &#123;ConicArcSensorOutlineGeometry&#125; from &#39;.&#x2F;ConicArcSensor&#x2F;ConicArcSensorOutlineGeometry&#39;;import &#123;ConicArcSensorGraphics&#125; from &#39;.&#x2F;ConicArcSensor&#x2F;ConicArcSensorGraphics&#39;;import &#123;ConicArcSensorCollection&#125; from &#39;.&#x2F;ConicArcSensor&#x2F;ConicArcSensorCollection&#39;;&#x2F;&#x2F;rectangularSensorCesium.RectangularSensorPrimitive &#x3D; RectangularSensorPrimitive;Cesium.RectangularSensorGraphics &#x3D; RectangularSensorGraphics;Cesium.RectangularSensorVisualizer &#x3D; RectangularSensorVisualizer;&#x2F;&#x2F;conicSensorCesium.ConicArcSensorGeometry &#x3D; ConicArcSensorGeometry;Cesium.ConicArcSensorOutlineGeometry &#x3D; ConicArcSensorOutlineGeometry;Cesium.ConicArcSensorGraphics &#x3D; ConicArcSensorGraphics;Cesium.ConicArcSensorCollection &#x3D; ConicArcSensorCollection;var DataSourceDisplay &#x3D; Cesium.DataSourceDisplay;var originalDefaultVisualizersCallback &#x3D; DataSourceDisplay.defaultVisualizersCallback;DataSourceDisplay.defaultVisualizersCallback &#x3D; function (scene, entityCluster, dataSource) &#123; var entities &#x3D; dataSource.entities; var array &#x3D; originalDefaultVisualizersCallback(scene, entityCluster, dataSource); return array.concat([ new RectangularSensorVisualizer(scene, entities) ]);&#125;; 支持升级到1.5X ,如需升级到1.6更改import导入方式，不支持直接导入。 开源地址:github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|通视分析","date":"2020-04-12T06:19:00.000Z","path":"2020/04/12/cesium-通视分析/","text":"效果通视分析是指以某一点为观察点，研究某一区域通视情况的地形分析。 示例通过cesium提供的碰撞检测api获取障碍点实现同时分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import PointDrawer from &#39;..&#x2F;..&#x2F;BaseTool&#x2F;Draw&#x2F;DrawPoint&#39;;import LineDrawer from &#39;..&#x2F;..&#x2F;BaseTool&#x2F;Draw&#x2F;DrawLine&#39;;import Coordinate from &#39;..&#x2F;..&#x2F;BaseTool&#x2F;Coordinate&#39;;import Cesium from &#39;Cesium&#39;export default class InterAnalysis &#123; &#x2F;&#x2F; viewer: any; &#x2F;&#x2F; interAnalysis_map: Map&lt;Symbol, any&gt;; &#x2F;&#x2F; lineEntities: any &#x3D; []; &#x2F;&#x2F; pointEntities: any[] &#x3D; []; constructor(viewer) &#123; this.viewer &#x3D; viewer; this.interAnalysis_map &#x3D; new Map(); this.pointEntities &#x3D; []; this.lineEntities &#x3D; []; &#125; create(sPoint, ePoint, objId) &#123; debugger if (ePoint.x &#x3D;&#x3D;&#x3D; sPoint.x &amp;&amp; ePoint.y &#x3D;&#x3D;&#x3D; sPoint.y &amp;&amp; ePoint.z &#x3D;&#x3D;&#x3D; sPoint.z) &#123; this.pointEntities.push(PointDrawer.draw(this.viewer, sPoint, 10, Cesium.Color.AQUAMARINE)); console.warn(&#39;通视起点与终点重叠&#39;); return; &#125; this.pointEntities.push(PointDrawer.draw(this.viewer, sPoint, 10, Cesium.Color.AQUAMARINE)); this.pointEntities.push(PointDrawer.draw(this.viewer, ePoint, 10, Cesium.Color.AQUAMARINE)); let obj &#x3D; this.drawVisibility(sPoint, ePoint).then((obstaclePoint) &#x3D;&gt; &#123; &#x2F;&#x2F;获取视觉障碍点, 绘制线段 if (!obstaclePoint) &#123; obstaclePoint &#x3D; ePoint; debugger return; &#125; this.lineEntities.push(LineDrawer.draw(this.viewer, [sPoint, obstaclePoint], Cesium.Color.GREEN)); this.lineEntities.push(LineDrawer.draw(this.viewer, [obstaclePoint, ePoint], Cesium.Color.RED)); &#125;); this.interAnalysis_map.set(objId, obj); &#125; &#x2F;&#x2F;绘制通视线 drawVisibility(sPoint, ePoint) &#123; var promise &#x3D; Cesium.when.defer(); var removePreRenderListener &#x3D; this.viewer.scene.postUpdate.addEventListener(() &#x3D;&gt; &#123; &#x2F;&#x2F;设置相机 var curCamera &#x3D; this.setCameraPositoion(sPoint, ePoint); var removePostRenderListener &#x3D; this.viewer.scene.postRender.addEventListener(() &#x3D;&gt; &#123; &#x2F;&#x2F;取点 var obstaclePoint &#x3D; this.getObstaclePoint(ePoint); &#x2F;&#x2F;重置相机 this.resetCamera(curCamera); removePreRenderListener(); var removeOverlayListener &#x3D; this.viewer.scene.postRender.addEventListener(function() &#123; removeOverlayListener(); &#125;); promise.resolve(obstaclePoint); removePostRenderListener(); &#125;); &#125;); return promise; &#125; &#x2F;&#x2F;设置相机位置 setCameraPositoion(sPoint, ePoint) &#123; let curCamera &#x3D; &#123; positon: this.viewer.camera.position.clone(), direction: this.viewer.camera.direction.clone(), up: this.viewer.camera.up.clone() &#125;; let direction &#x3D; this.calculateDirection(sPoint, ePoint); let location &#x3D; Coordinate.cartesian2lonlat(sPoint); let position1 &#x3D; Cesium.Cartesian3.fromDegrees(location.longitude, location.latitude, location.height + 0.1); this.viewer.camera.setView(&#123; destination: position1, orientation: &#123; direction: direction, up: this.viewer.camera.up.clone() &#125; &#125;); return curCamera; &#125; &#x2F;&#x2F;获取障碍点 getObstaclePoint(ePoint) &#123; let screenLocation &#x3D; this.viewer.scene.cartesianToCanvasCoordinates(ePoint); if (!screenLocation) &#123; console.warn(&#39;获取屏幕坐标失败&#39;); return ePoint; &#125; let obstaclePoint &#x3D; this.viewer.scene.pickPosition(screenLocation); return obstaclePoint; &#125; &#x2F;&#x2F;重置相机 resetCamera(camera) &#123; this.viewer.camera.setView(&#123; destination: camera.positon, orientation: &#123; direction: camera.direction, up: camera.up &#125; &#125;); &#125; &#x2F;&#x2F;计算方向 calculateDirection(p1, p2) &#123; return Cesium.Cartesian3.normalize( Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3()), new Cesium.Cartesian3() ); &#125; &#x2F;&#x2F;清除绘制 clearDraw() &#123; if (this.pointEntities.length &gt; 0) &#123; for (let i &#x3D; 0; i &lt; this.pointEntities.length ; i++) &#123; this.viewer.entities.removeById(this.pointEntities[i].id); &#125; &#125; if (this.lineEntities.length &gt; 0) &#123; for (let _i &#x3D; 0; _i &lt; this.lineEntities.length; _i++) &#123; this.viewer.entities.removeById(this.lineEntities[_i].id); &#125; &#125; &#125;&#125; 该示例只是将碰撞点的位置截取出来，渲染成两种颜色,还可以进一步添加分析结果和环视分析。 开源地址:github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|可视域分析","date":"2020-04-12T05:53:00.000Z","path":"2020/04/12/cesium-可视域分析实现/","text":"效果可视域在三维中是比较常用的分析功能，很多领域中都能应用到。 示例创建起终点，模拟相机的视锥绘制视锥体，创建点光源添加阴影效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182import Coordinate from &#39;..&#x2F;..&#x2F;BaseTool&#x2F;Coordinate&#39;;import Cesium from &#39;Cesium&#39;import PointDrawer from &#39;..&#x2F;..&#x2F;BaseTool&#x2F;Draw&#x2F;DrawPoint&#39;;export default class Viewshed &#123; &#x2F;&#x2F; viewer: any; &#x2F;&#x2F; vishedfrustum: any &#x3D; null; &#x2F;&#x2F; pointEntities: any[] &#x3D; []; constructor(viewer) &#123; this.viewer &#x3D; viewer; this.pointEntities &#x3D; []; &#125; init(pointArr) &#123; if(pointArr.length &#x3D;&#x3D;&#x3D; 1)&#123; this.pointEntities.push(PointDrawer.draw(this.viewer, pointArr[0], 10, Cesium.Color.AQUAMARINE)) &#125; else if(pointArr.length &#x3D;&#x3D;&#x3D; 2)&#123; this.pointEntities.push(PointDrawer.draw(this.viewer, pointArr[0], 10, Cesium.Color.AQUAMARINE)); this.pointEntities.push(PointDrawer.draw(this.viewer, pointArr[1], 10, Cesium.Color.AQUAMARINE)); this.createViewshedMap(pointArr[0], pointArr[1]); &#125; &#125; exit() &#123; &#x2F;&#x2F;clear point arr this.pointEntities.forEach(item &#x3D;&gt; &#123; this.viewer.entities.remove(item); &#125;); this.pointEntities &#x3D; []; &#x2F;&#x2F;stop shadowMap &#x2F;&#x2F; PopCity.viewer.scene.shadowMap.enabled &#x3D; false; &#x2F;&#x2F;clear primitive if (this.vishedfrustum) &#123; this.viewer.scene.primitives.remove(this.vishedfrustum); this.vishedfrustum &#x3D; false; &#125; this.viewer.scene.primitives._primitives.forEach((item, index) &#x3D;&gt; &#123; if (item.name &#x3D;&#x3D;&#x3D; &#39;VIEWSHEDPRIMITIVE&#39;) &#123; this.viewer.scene.primitives._primitives.splice(index, 1); &#125; &#125;); &#125; &#x2F;&#x2F;核心代码 createViewshedMap(start, end) &#123; var scene &#x3D; this.viewer.scene; var spotLightCamera &#x3D; new Cesium.Camera(scene); spotLightCamera.position &#x3D; start; spotLightCamera.direction &#x3D; this.calculateDirection(start, end); spotLightCamera.up &#x3D; Cesium.Cartesian3.clone(this.viewer.camera.up); spotLightCamera.frustum.fov &#x3D; Cesium.Math.PI_OVER_THREE; spotLightCamera.frustum.near &#x3D; 0.1; spotLightCamera.frustum.far &#x3D; Cesium.Cartesian3.distance(start, end); &#x2F;&#x2F;绘制视锥体 this.drawFrustum(start, end, spotLightCamera.frustum); var viewshedOptions &#x3D; &#123; context: scene.context, lightCamera: spotLightCamera, cascadesEnabled: false, softShadows: true, viewshed: true &#125;; var viewshed &#x3D; new Cesium.ShadowMap(viewshedOptions); viewshed.enabled &#x3D; true; viewshed.size &#x3D; 1024; &#x2F;&#x2F; const ViewshedPrimitive &#x3D; function(this, shadowMap) &#123; &#x2F;&#x2F; this.shadowMap &#x3D; shadowMap; &#x2F;&#x2F; this.name &#x3D; &#39;VIEWSHEDPRIMITIVE&#39;; &#x2F;&#x2F; &#125; &#x2F;&#x2F; var that &#x3D; this; const ViewshedPrimitive &#x3D; function(shadowMap) &#123; this.shadowMap &#x3D; shadowMap; this.name &#x3D; &#39;VIEWSHEDPRIMITIVE&#39;; &#125;; ViewshedPrimitive.prototype.update &#x3D; function(frameState) &#123; frameState.shadowMaps.push(this.shadowMap); &#125;; scene.primitives.add(new ViewshedPrimitive(viewshed)); &#125; &#x2F;&#x2F;计算方向 calculateDirection(p1, p2) &#123; return Cesium.Cartesian3.normalize( Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3()), new Cesium.Cartesian3() ); &#125; drawFrustum(position1, position2, frustum) &#123; var orientation &#x3D; this.calculateorigntation(position1, position2); var primitive &#x3D; new Cesium.Primitive(&#123; geometryInstances: new Cesium.GeometryInstance(&#123; geometry: new Cesium.FrustumOutlineGeometry(&#123; frustum: frustum, origin: position1, orientation: orientation &#125;), attributes: &#123; color: Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 0.0, 1.0)) &#125; &#125;), appearance: new Cesium.PerInstanceColorAppearance(&#123; flat: true &#125;) &#125;); this.viewer.scene.primitives.add(primitive); this.vishedfrustum &#x3D; primitive; &#125; calculateorigntation(p1, p2) &#123; var co1 &#x3D; Coordinate.cartesian2lonlat(p1); var co2 &#x3D; Coordinate.cartesian2lonlat(p2); var width &#x3D; Coordinate.catchDistancefromCartographic2D( co1.longitude, co1.latitude, co2.longitude, co1.latitude ); var length &#x3D; Coordinate.catchDistancefromCartographic2D( co1.longitude, co1.latitude, co1.longitude, co2.latitude ); var height &#x3D; co1.height - co2.height; var distance &#x3D; Coordinate.catchDistancefromCartographic2D( co1.longitude, co1.latitude, co2.longitude, co2.latitude ); var angle &#x3D; Math.atan(width &#x2F; length); var tilt &#x3D; Math.atan(height &#x2F; distance); if (co1.latitude &gt; co2.latitude) &#123; angle &#x3D; Math.PI - angle; &#125; if (co1.longitude &gt; co2.longitude) &#123; angle &#x3D; -angle; &#125; var heading &#x3D; angle; var pitch &#x3D; 0; var roll &#x3D; -Math.PI &#x2F; 2 - tilt; var hpr &#x3D; new Cesium.HeadingPitchRoll(heading, pitch, roll); var orientation &#x3D; Cesium.Transforms.headingPitchRollQuaternion(p1, hpr); return orientation; &#125; clearDraw() &#123; &#x2F;&#x2F;清除点 if (this.pointEntities &amp;&amp; this.pointEntities.length &gt; 0) &#123; for (var i &#x3D; 0; i &lt; this.pointEntities.length ; i++) &#123; this.viewer.entities.remove(this.pointEntities[i]); &#x2F;&#x2F; pointArr.splice(i,1); &#125; &#125; &#x2F;&#x2F;清除视锥 if (this.vishedfrustum) &#123; this.viewer.scene.primitives.remove(this.vishedfrustum); &#125; &#x2F;&#x2F;清除阴影 this.viewer.scene.primitives._primitives.forEach((item, index) &#x3D;&gt; &#123; if (item.name &#x3D;&#x3D;&#x3D; &#39;VIEWSHEDPRIMITIVE&#39;) &#123; this.viewer.scene.primitives._primitives.splice(index, 1); &#125; &#125;); &#125;&#125; 实现效果比较粗糙 开源地址:github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"Vue|父子组件的通信","date":"2020-04-11T14:19:00.000Z","path":"2020/04/11/Vue/","text":"方式ref： 父组件中调用子组件的方法并向子组件传参。 emit： 子组件触发父组件的方法并传递参数。 props： 父组件向子组件动态传值。 示例refref 在元素或自组件中标记能访问的对象。 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;p ref&#x3D;&quot;p&quot;&gt;ref-test&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, mounted() &#123; console.log(this.$refs.p) &#125; &#125;&lt;&#x2F;script&gt;&lt;template&gt; &lt;div&gt; &lt;p ref&#x3D;&quot;p&quot;&gt;ref-test&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123;&#125; &#125;, mounted() &#123; console.log(this.$refs.p) &#125; &#125;&lt;&#x2F;script&gt;&#x2F;&#x2F;父组件文件&#x2F;&#x2F;引入组件&lt;com ref&#x3D;&quot;com&quot;&gt;&lt;&#x2F;com&gt;&#x2F;&#x2F;打印数据console.log(this.$refs.com) 1 这里我们只能取到组件的值或调用方法，不可以通过这个方法改变组件的相关属性值。2 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs也不是响应式的，因此不可以用它在模板中做数据绑定。 emit和props1、父组件可以使用 props 把数据传给子组件。 2、子组件可以使用 $emit 触发父组件的自定义事件。 vm.$emit( event, arg ) //触发当前实例上的事件 vm.$on( event, fn );//监听event事件后运行 fn； 子组件 1234567891011121314151617181920&lt;template&gt; &lt;div class&#x3D;&quot;train-city&quot;&gt; &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;&#x2F;h3&gt; &lt;br&#x2F;&gt;&lt;button @click&#x3D;&#39;select(&#96;大连&#96;)&#39;&gt;点击此处将‘大连’发射给父组件&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name:&#39;trainCity&#39;, props:[&#39;sendData&#39;], &#x2F;&#x2F; 用来接收父组件传给子组件的数据 methods:&#123; select(val) &#123; let data &#x3D; &#123; cityname: val &#125;; this.$emit(&#39;showCityName&#39;,data);&#x2F;&#x2F;select事件触发后，自动触发showCityName事件 &#125; &#125; &#125; &lt;&#x2F;script&gt; 父组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;&#x2F;div&gt; &lt;train-city @showCityName&#x3D;&quot;updateCity&quot; :sendData&#x3D;&quot;toCity&quot;&gt;&lt;&#x2F;train-city&gt; &lt;template&gt; &lt;script&gt; import TrainCity from &quot;.&#x2F;train-city&quot;; export default &#123; name:&#39;index&#39;, components: &#123;TrainCity&#125;, data () &#123; return &#123; toCity:&quot;北京&quot; &#125; &#125;, methods:&#123; updateCity(data)&#123;&#x2F;&#x2F;触发子组件城市选择-选择城市的事件 this.toCity &#x3D; data.cityname;&#x2F;&#x2F;改变了父组件的值 console.log(&#39;toCity:&#39;+this.toCity) &#125; &#125; &#125; &lt;&#x2F;script&gt; 传递参数需要: 12345671、传递参数时要用—代替驼峰命名，HTML不区分大小写2、sendProp要在父组件的data中定义，例如 sendProp:&#39;&#39;3、messageProp在子组件的props中声明类型，例如 messageProp: String4、在利用props实现传值的过程中理论上是要实现单向传递，即父组件改变相关参数的值，子组件也相应变化，但是子组件对参数的改变不应该影响父组件。但是当props中接收的是父组件传递的引用类型（对象或者是数组）时，在子组件中对数据改变时，父组件中的数据也会相应的改变，因为两者是指向的同一地址内存。如果不想子组件的改变影响父组件可以利用深拷贝，将接受的数据进行深拷贝后在子组件中使用，而不直接操作接受的数据。 vue常用组件:https://www.jianshu.com/p/c9b3df751f36?utm_campaign=haruki vue通用组件封装:https://www.jianshu.com/p/233d17dfbd16","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"cesium|多线程的实现","date":"2020-04-11T13:48:00.000Z","path":"2020/04/11/cesium-多线程的实现/","text":"Web Worker什么是 web worker js本身是一种单线程设计，我们无法在同一时刻并行运行多个脚本。虽然可以用setInterval，setTimeout方法来模拟多线程，但实际上这些方法都是存在于主线程使用的一个事件循环里，一旦存在一个耗时操作，就会牵制主线程的操作，导致页面卡顿。 Web Worker通过引入类似线程的机制使这种问题得到了解决，通过在当前js主线程中使用worker类加载一个js文件来开辟一个新线程，起到互不阻塞执行的效果。这个js worker运行在另一个全局上下文中，不同于当前的window，所以不能用window变量来获取当前全局的范围。 什么时候使用 1 当需要一个js脚本进行大量的复杂计算时候，通过postMessage和onmessage进行通信 2 功能模块化。importScripts这个方法只能在worker线程中执行，该方法可以在worker线程中引入多个脚本，则该线程可以使用所引入脚本中的任意变量和函数。 3 当需要执行一个不断向后台发送更新请求的时候，可以将这个过程放到工作线程里，然后将结果返回给主线程。 如何使用 ①创建一个线程：通过new一个Worker实例来创建一个线程，构造函数参数传递一个指向js文件资源的url。const worker = new Worker(&#39;a.js&#39;) ②与一个线程通信：主线程 1234567onload &#x3D;function()&#123; var worker &#x3D;new Worker(&#39;a.js&#39;); worker.onmessage &#x3D; function (evt) &#123;&#x2F;&#x2F;接收子线程消息 console.log(evt.data); &#x2F;&#x2F;hello received &#125;; worker.postMessage(&quot;hello&quot;)&#x2F;&#x2F;向子线程发送消息&#125; 子线程 1234onmessage &#x3D;function(event) &#123; &#x2F;&#x2F;接收主线程消息 let str &#x3D; event.data; postMessage(str+&quot; received&quot;); &#x2F;&#x2F;发送子线程消息&#125;; 在主线程中，消息事件依托于创建出来的worker对象，而在工作线程中，消息事件依托于全局对象。 当工作线程完成了任务后，需要调用terminate方法来释放内存和避免僵尸线程的情况：worker.terminate(); cesium实现的多线程如何使用: 1 用户只需要创建一个TaskProcessor，指定具体需要创建线程的类型 ：圆 2 然后调用scheduleTask，里面是该对象的具体参数 : 圆position + 半径 3 处理结果通过promise机制返回一个异步对象，方便用户使用 cesium设计的多线程会通过创建TaskProcessor指定参数给scheduleTask最后计算通过Promise机制返回异步处理。内部通过require关联对应的功能函数，并替换onmessage函数。 cesium的底层实现 : 原理篇 ： https://www.cnblogs.com/fuckgiser/p/5869122.html","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium| PostProcessStage后期处理","date":"2020-04-10T10:24:00.000Z","path":"2020/04/10/cesium-postProcessStages后期处理添加特效/","text":"前言cesium中提供了postProceSsstagge接口,能在三维场景中添加后期渲染效果。处理对包括模型描边、黑白图、明亮度调整、夜视效果、环境光遮蔽。 原理篇：https://www.cnblogs.com/webgl-angela/p/9272810.html 后期处理原理图 后期处理的过程有点类似于照片的PS。生活中拍摄了一张自拍照，看到照片后发现它太暗了，于是我们增加亮度得到了一张新的照片。在增加亮度后发现脸上的痘痘清晰可见，这可不是我们希望的效果，于是再进行一次美肤效果处理。在这之后可能还会进行n次别的操作，直到满足我们的要求。上述这个过程和三维里面的后期处理流程非常类似：拍的原始照片相当于三维场景中实际渲染得到的效果，在此基础上进行物体描边、夜视效果、环境光遮蔽等后期处理，最后渲染到场景中的图片相当于定版的最终照片。 总结 ： 后期处理其实是一个叠加修改的过程，通过不同步骤的加工，最后得到想要的结果 处理流程：PostProcessStage主要相关接口: PostProcessStage：对应于某个具体的后期处理效果，它的输入为场景渲染图或者上一个后期处理的结果图，输出结果是一张处理后的图片。 PostProcessStageComposite：一个集合对象，存储类型为PostProcessStage或者PostProcessStageComposite的元素。 PostProcessStageLibrary：负责创建具体的后期处理效果，包括Silhouette、Bloom、AmbientOcclusion等，创建返回的结果是PostProcessStageComposite或者PostProcessStage类型。 PostProcessStageCollection：是一个集合类型的类，负责管理和维护放到集合中的元素 ，元素的类型是PostProcessStage或者PostProcessStageComposite。 添加后期效果流程： 1 通过PostProcessStageLibrary创建一个或者多个后处理效果对象，得到多个PostProcessStage或者PostProcessStageComposite。2 将他们加入到PostProcessStageCollection对象中。这样PostProcessStageCollection对象就会按照加入的顺序进行屏幕后期处理，在所有的效果都处理完毕后，执行FXAA，3 绘制到屏幕上。 示例添加场景亮度添加片段着色器，调整纹理颜色放大系数实现亮度调整 1234567891011121314151617181920var fs &#x3D; &#39;uniform sampler2D colorTexture;\\n&#39; + &#39;varying vec2 v_textureCoordinates;\\n&#39; + &#39;uniform float scale;\\n&#39; + &#39;uniform vec3 offset;\\n&#39; + &#39;void main() &#123;\\n&#39; + &#39; vec4 color &#x3D; texture2D(colorTexture, v_textureCoordinates);\\n&#39; + &#x2F;&#x2F;获取片段颜色 &#39; gl_FragColor &#x3D; vec4(color.rgb * scale + offset, 10.0);\\n&#39; + &#39;&#125;\\n&#39;; &#x2F;&#x2F;放大片段颜色系数 viewer.scene.postProcessStages.add(new Cesium.PostProcessStage(&#123; fragmentShader: fs, uniforms: &#123; scale: 1.1, offset: function () &#123; &#x2F;&#x2F; return new Cesium.Cartesian3(0.1, 0.2, 0.3); return new Cesium.Cartesian3(0.01, 0.02, 0.03); &#125; &#125; &#125;)); 效果 添加雾气粒子效果:csdn博客 添加一个动态扩散圆:csdn博客","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium| Primitive图元自定义着色器(1)","date":"2020-04-10T07:21:00.000Z","path":"2020/04/10/cesium-primitive图元自定义着色器/","text":"前言Primitive是cesium核心api之一，与entity方式绘制方式(基于数据)不同，primitive更接近渲染引擎底层。entity适合以数据绘制实体，而primitive更适合图形学对有webgl经验的更亲和。primitive绘制的图形比entity添加的实体性能更好，webgl特性使primitive能绘制更多样式的图形。 对entity和primitive与scene之间的关联可以参考 【cesiumAPI笔记篇】 Primitive特性 1234567891011121 由两部分组成（1）几何形状（Geometry）：定义了Primitive的结构，例如三角形、线条、点等（2）外观（Appearance ）：定义Primitive的着色（Sharding），包括GLSL（OpenGL着色语言，OpenGL ShadingLanguage）顶点着色器和片段着色器（ vertex and fragment shaders），以及渲染状态（render state）2 使用Geometry和Appearance 具有以下优势：（1）性能：绘制大量Primitive时，可以将其合并为单个Geometry以减轻CPU负担、更好的使用GPU。合并Primitive由web worker线程执行，UI保持响应性（2）灵活性：Geometry与Appearance 解耦，两者可以分别进行修改（3）低级别访问：易于编写GLSL 顶点、片段着色器、使用自定义的渲染状态3 同时具有以下劣势：（1）需要编写更多地代码（2）需要对图形编程有更多的理解，特别是OpenGL的知识 Primitive详解 ：https://www.jianshu.com/p/5a74c607a591 示例数据准备1234567891011121314&#x2F;&#x2F;雷达的高度var length &#x3D; 400000.0;&#x2F;&#x2F;地面位置(垂直地面) var positionOnEllipsoid &#x3D; Cesium.Cartesian3.fromDegrees(116.39, 39.9);&#x2F;&#x2F;中心位置var centerOnEllipsoid &#x3D; Cesium.Cartesian3.fromDegrees(116.39, 39.9, length*0.5);&#x2F;&#x2F; 顶部位置(卫星位置)var topOnEllipsoid &#x3D; Cesium.Cartesian3.fromDegrees(116.39, 39.9,length);&#x2F;&#x2F;矩阵计算var modelMatrix &#x3D; Cesium.Matrix4.multiplyByTranslation( &#x2F;&#x2F;转换矩阵 Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid), &#x2F;&#x2F;矩阵 new Cesium.Cartesian3(0.0, 0.0, length * 0.5), &#x2F;&#x2F;要转换的笛卡尔坐标 new Cesium.Matrix4() &#x2F;&#x2F;返回新的矩阵 ); Geometry创建一个圆锥几何图形 12345678910111. 构造geometryvar cylinderGeometry &#x3D; new Cesium.CylinderGeometry(&#123; length: length, topRadius: 0.0, bottomRadius: length * 0.5, vertexFormat: Cesium.MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat&#125;);2. 创建GeometryInstancevar redCone &#x3D; new Cesium.GeometryInstance(&#123; geometry: cylinderGeometry, &#x2F;&#x2F;geomtry类型 modelMatrix: modelMatrix, &#x2F;&#x2F;模型矩阵 调整矩阵的位置和方向&#125;); shader着色器定义glsl代码 1234567891011121314151617181920let source &#x3D;&#x2F;&#x2F;传入的动态数值&#96;uniform vec4 color; uniform float repeat; uniform float offset; uniform float thickness;&#x2F;&#x2F;设置图形外观材质czm_material czm_getMaterial(czm_materialInput materialInput)&#123; czm_material material &#x3D; czm_getDefaultMaterial(materialInput); &#x2F;&#x2F;获取内置的默认材质 float sp &#x3D; 1.0&#x2F;repeat; &#x2F;&#x2F;重复贴图 vec2 st &#x3D; materialInput.st; &#x2F;&#x2F;二维纹理坐标 float dis &#x3D; distance(st, vec2(0.5)); &#x2F;&#x2F;计算距离 float m &#x3D; mod(dis + offset, sp); &#x2F;&#x2F;间隔 float a &#x3D; step(sp*(1.0-thickness), m);&#x2F;&#x2F;线条拼色 &#x2F;&#x2F;修改材质 material.diffuse &#x3D; color.rgb; material.alpha &#x3D; a * color.a; return material;&#125;&#96; 自定义shader着色器 和 Material ：https://www.cnblogs.com/fuckgiser/p/6171245.html appearance自定义material外观材质，修改着色器 12345678910111213let material &#x3D; new Cesium.Material(&#123; fabric: &#123; type: &#39;VtxfShader1&#39;, uniforms: &#123; &#x2F;&#x2F;动态传递参数 color: new Cesium.Color(0.2, 1.0, 0.0, 1.0), repeat: 30.0, offset: 0.0, thickness: 0.3, &#125;, source ：source &#125;, translucent: false&#125;) 定义appearance外观 12345let appearance &#x3D; new Cesium.MaterialAppearance(&#123; material：material，&#x2F;&#x2F;自定义的材质 faceForward : false, &#x2F;&#x2F; 当绘制的三角面片法向不能朝向视点时，自动翻转法向， 从而避免法向计算后发黑等问题 closed: true &#x2F;&#x2F; 是否为封闭体，实际上执行的是是否进行背面裁剪&#125;) 创建Primitive创建自定义primitive图元，实现动态效果 12345678910111213141516&#x2F;&#x2F;添加Primitive var radar &#x3D; viewer.scene.primitives.add( new Cesium.Primitive(&#123; geometryInstances: [redCone], appearance：appearance &#125;)); &#x2F;&#x2F;动态修改雷达材质中的offset变量，从而实现动态效果。 viewer.scene.preUpdate.addEventListener(function() &#123; var offset &#x3D; radar.appearance.material.uniforms.offset; offset -&#x3D; 0.001; if (offset &gt; 1.0) &#123; offset &#x3D; 0.0; &#125; radar.appearance.material.uniforms.offset &#x3D; offset; &#125;) 效果","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"随笔|cesium的Entity动态效果实现","date":"2020-04-10T03:55:00.000Z","path":"2020/04/10/随笔-cesium实体动态效果实现/","text":"前言前面讲了cesium的API学习大概思路，对一些api不是很了解的可以基于那个框架去延伸。这路在看下cesium中对实体动态修改提供的内置对象 property 原理篇 博客园 ：https://www.cnblogs.com/yanan-boke/p/7447997.html vxtf简书 ：https://www.jianshu.com/p/f0b47997224c 随笔借图 cesium中每一个entity属性都是一个property实例,实例提供了基本的属性方法getValue,setValue以及equals。基于property基类提供positionProperty,materialProperty等拓展类，实现了更多效果和衍生。 Entity封装属性示例 :Cesium中提供了defineProperties方法，继承Object.defineProperties新版cesium改成使用Object。 12345678910111213141516171819202122232425262728function Entity(options) &#123; var id &#x3D; options.id; if (!defined(id)) &#123; id &#x3D; createGuid(); &#125; this._id &#x3D; id; this._name &#x3D; options.name; this._description &#x3D; undefined; this._position &#x3D; undefined; this._rectangle &#x3D; undefined;&#125;&#x2F;&#x2F; Key 1:definePropertiesdefineProperties(Entity.prototype, &#123; id : &#123; get : function() &#123; return this._id; &#125; &#125;, &#x2F;&#x2F; Key 2:createRawPropertyDescriptor name : createRawPropertyDescriptor(&#39;name&#39;), &#x2F;&#x2F; Key 3:createPropertyDescriptor description : createPropertyDescriptor(&#39;description&#39;), &#x2F;&#x2F; Key 4:createPositionPropertyDescriptor position : createPositionPropertyDescriptor(&#39;position&#39;), &#x2F;&#x2F; Key 5:createPropertyTypeDescriptor rectangle : createPropertyTypeDescriptor(&#39;rectangle&#39;, RectangleGraphics)&#125;); Cesium中的成员变量和属性方法之间就是一个下划线_，比如成员变量为_id，对应的属性方法为id，这是Cesium中的一个规范。 PropertyProperty基本类型: 区分:Property都是可以赋值给Entity的任意属性实例。 SampleProperty ：用来通过给定多个不同时间点的Sample，然后在每两个时间点之间进行线性插值的一种Property TimeIntervalCollectionProperty ：该Property用来指定各个具体的时间段的属性值，每个时间段内的属性值是恒定的，并不会发生变化，除非已经进入到下一个时间段 ConstantProperty：最常用的property，cesium在给实体赋值自动将数值转换成property实例:enity.box.dimensions = new ConstantProperty(new Cesium.Cartesian3(400000.0, 300000.0, 200000.0)); CompositeProperty ： 可以把多种不同类型的ConstantProperty、SampleProperty、TimeIntervalCollectionProperty等Property组合在一起来操作。比如前一个时间段需要线性运动，后一段时间再跳跃式运动 PositionProperty类型 : 内置的接口和property的基本接口作用一样，作用于position的 区分：不可实例化，只能用来表示position，拓展property接口 SampledPositionProperty：同SampleProperty作用一样，多了一个位置插值setInterpolationOptions用来表示不同差值的类型:线性插值,Lagrange插值,Hermite插值。 MaterialProperty类型: 作用于Material外观材质的，基本材质的property接口。 区分：只能用来表示Material，拓展property接口 ColorMaterialProperty 示例： 123456789var colorProperty &#x3D; new Cesium.SampledProperty(Cesium.Color); colorProperty.addSample(Cesium.JulianDate.fromIso8601(&#39;2019-01-01T00:00:00.00Z&#39;), new Cesium.Color(0, 1, 0)); colorProperty.addSample(Cesium.JulianDate.fromIso8601(&#39;2019-01-03T00:00:00.00Z&#39;), new Cesium.Color(0, 0, 1)); blueBox.box.material &#x3D; new Cesium.ColorMaterialProperty(colorProperty); 其他类型的Property: CallbackProperty ：是自由度最高的一种Property，让用户通过自定义，回调函数，来返回需要的值。回调函数中，用户可以使用time来给定value，也可以以自己的方式给给定。 ReferenceProperty ： 该Property可以直接链接到别的对象的Property上，相当于引用，省得自己构建了。比如这里我创建了一个红色的盒子redBox，希望它和之前的蓝色盒子一起变大 PropertyBag ：可以包装一个对象(JS中的对象概念)，该对象的每一个属性(JS中的属性概念)，都可以作为一个动态的Property。 PropertyArray ： 包装一个对象，内部封装了一个数组。 VelocityOrientationProperty ：该Property用来Entity的position的位置变化，来计算出移动的方向，最后把速度方向输出成Orientation。这里可以实现动态路径绑定跟踪扫描物体。 VelocityVectorProperty ：和VelocityOrientationProperty一样，不过是速度方向输出成一个预设的Vector。","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"随笔|cesiumAPI笔记","date":"2020-04-10T02:34:00.000Z","path":"2020/04/10/cesium-温习API/","text":"前言学习cesium有一段时间了，也做了几个三维项目。但每次翻Api时感觉了解的还是不够深，只是基于上层Api的调用，感叹cesium水太深不愧是一群研究数学和图形的大佬写的，在此之前还真得把webgl好好补补。 Cesium原理篇 法克鸡丝博客园：https://www.cnblogs.com/fuckgiser/p/5706842.html Cesium Api学习指南 vxtf简书: https://www.jianshu.com/p/9a71186edd5b 随笔借图 学习cesium时可以根据这个结构去延伸 viewer ：三维窗口元素集合，所有组件对象的入口。管理组件和api对象使用 cesiumWidget ：三维窗口,创建所需有的元素包含scene管理三维场景对象，学习过webgl的想必不会陌生。canvas画布对象还有clock时钟对象等组成。container三维窗口创建挂载的容器。screenSpaceEvenHandler三维窗口的事件类，封装了鼠标，手势等基本事件。 dataSourceDisplay ： viewer向三维场景中添加三维对象的接口。所有外部数据源管理的入口。dataSourceDisplay添加完外部数据之后会关联到scene三维场景中，操作修改数据相应也会修改三维场景的关联对象。defaultDataSource相当于内置dataSource，添加实体只需要viewer.entities无需手动创建，底层是使用dataSourceDisplay.defaultDataSource.entities,其他数据源对象则需要另外添加。 UI组件 ： 三维窗口的ui组件集合，都可以通过viewer.xx来调用管理。 scene ：三维场景对象。三维场景包含globe地球类，地球表皮影像和地形数据的渲染。primitives表示加入三维场景中的各种三维对象。groundPrimitives用来表示贴地的三维对象。viewer.entities加入场景中的三维实体，大多会转化成primitives和groundPrimitives。 primitive：三维场景中的一个基本绘制图元对象。primitive提供更多的图形绘制功能，可以自定义图元类型和外观。使用着色器渲染图形对象，使用shader定制更好的效果。 entity ： 三维实体,cesium基于数据的封装,对图形不是很了解的学习者很友善。基于entity的动态效果cesium提供了Property对象。 以上就是cesium的大体结构，具体的scene和dataSourceDisplay的数据关联可以参考vxtf的博客。","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|三维标绘工具","date":"2020-04-08T09:29:00.000Z","path":"2020/04/08/cesium-三维标绘工具/","text":"示例图形标绘 军事标绘 动态标绘 功能正在完善… 实现1234567891011121314151617181920212223242526272829303132import DrawDynamicTool from &#39;.&#x2F;DrawDynamicTool&#39;;import DrawMilitaryTool from &#39;.&#x2F;DrawMilitaryTool&#39;;export default class PlotHelper&#123; constructor(core)&#123; this.viewe &#x3D; core; &#x2F;&#x2F;初始化 this.initPlot() &#125; &#x2F;&#x2F;初始化标绘控件 initPlot()&#123; &#x2F;&#x2F;图形标绘 this.DrawDynamicTool &#x3D; new DrawDynamicTool(this.viewe); &#x2F;&#x2F;军事标绘 this.DrawMilitaryTool &#x3D; new DrawMilitaryTool(this.viewe); &#125; &#x2F;&#x2F;绘制 draw(cmd,type)&#123; if(!cmd)return false; switch(cmd)&#123; case &quot;图形&quot; : this.DrawDynamicTool.draw(type);break; case &quot;军事&quot; : this.DrawMilitaryTool.draw(type);break; case &quot;特殊&quot; : break; &#125; &#125; &#x2F;&#x2F;清除 clear()&#123; this.DrawMilitaryTool.clearAll(); this.DrawDynamicTool.remove(); &#125;&#125; 代码篇幅过长 DrawDynamicTool 和 DrawMilitaryTool在github示例上 三维可视化：博客","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"excel|数据处理之自动排序自动加载","date":"2020-04-08T09:14:00.000Z","path":"2020/04/08/excel-数据处理之自动排序自动加载/","text":"前言在处理数据时，如果量级不是很大的话，excel的数据透视表比mysql之类的数据库要方便很多，这里通过数据透视筛选完成之后进行动态展示。 效果制作下拉选自动排序使用 VLOOKUP() ,HLOOKUP()，RANK() 函数 准备一份数据源表 新建一个sheet，创建城市数据表 1 将城市选项制作成下拉格式：数据-数据有效性-序列-选在范围（数据源表的城市行） 2 feature和变量名直接从数据源表按顺序复制过来 3 第四列的逻辑：=HLOOKUP(D1,数据表!C1:LD27,2,0) 列名是上海的第二个数。然后依次往下 4 第一列逻辑：=RANK(D2,$D$2:$D$27) 第四列从大到小的排名 自动排序表 1）第一列 手动输入top1-20 2）使用 VLOOKUP()函数将城市数据表中对应的序号匹配过来 3）完成自动排序 可动态选择查看数据并列出top10，top20的列","tags":[{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"excel| 数据分析之变量相关性分析","date":"2020-04-08T09:05:00.000Z","path":"2020/04/08/excel-数据分析之相关性系数分析/","text":"前言之前项目需要，在数据分析这块学习了一段时间，使用excel的数据分析高级功能对模型预测出来的数据和统计年鉴的数据做了一下相关性分析。 准备 准备预测好的数据和统计年鉴的数据 使用excel并拓展数据分析工具 选择excel数据加载项 勾选数据分析并使用 分析数据分析 - 相关系数 - 选择输入范围 - 输出范围 点击确认计算出相关R值 ：R值0.4～0.6属于弱相关 计算R方：插入散点图 - 添加线性 - - 显示公式和R方 说明 : python可以直接用pandas的矩阵相关系数corr()输出","tags":[{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"cesium|三维分析功能","date":"2020-04-07T08:34:00.000Z","path":"2020/04/07/cesium-三维分析功能/","text":"示例概览 测控分析 过境分析 实现部分代码重构完善中… 三维量测功能：csdn地址 (未重构)","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|三维风场插件","date":"2020-04-07T08:24:00.000Z","path":"2020/04/07/cesium-三维风场插件/","text":"效果 实现支持.nc数据上图 根据项目改动 轮子地址： github地址","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|基于dat的场景控制控件","date":"2020-04-07T08:13:00.000Z","path":"2020/04/07/cesium-基于dat的场景控制控件/","text":"示例 实现基于dat.GUI的场景控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104let sceneTree &#x3D; new SceneTree(viewer); let Options &#x3D; function () &#123; this.fog &#x3D; true; this.lighting &#x3D; false; this.lensFlare &#x3D; false; this.groundAtmosphere &#x3D; true; this.rain &#x3D; false; this.snow &#x3D; false; this.sun &#x3D; true; this.skyBox &#x3D; true; this.globe &#x3D; true; this.sbstyle &#x3D; false; this.depthTestAgainstTerrain &#x3D; false; this.rotation &#x3D; false; this.grid &#x3D; false; this.tileGrid &#x3D; false; this.mgrsGrid &#x3D; false; this.navi &#x3D; true; this.timeLine &#x3D; false; this.info &#x3D; false; this.sbjk &#x3D; true; this.cesiumTool &#x3D; false; this.radar &#x3D; false; this.province &#x3D; false; this.terrain &#x3D; false; this.tiles &#x3D; false; this.btnCut &#x3D; function () &#123; Config.cutScene(viewer); &#125;; &#125; let option &#x3D; new Options(); let gui &#x3D; new dat.GUI(); gui.__closeButton.innerHTML &#x3D; &quot;收缩面板&quot;; gui.add(option, &#39;fog&#39;).name(&quot;雾天&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;fog&quot;: value &#125;); &#125;) gui.add(option, &#39;lighting&#39;).name(&quot;昼夜&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;lighting&quot;: value &#125;); &#125;) gui.add(option, &#39;lensFlare&#39;).name(&quot;光晕&quot;).onChange(function (value) &#123; lensFlare.enabled &#x3D; value; &#125;) gui.add(option, &#39;groundAtmosphere&#39;).name(&quot;大气层&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;groundAtmosphere&quot;: value &#125;); &#125;) gui.add(option, &#39;rain&#39;).name(&quot;雨天&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;rain&quot;: value &#125;); &#125;) gui.add(option, &#39;snow&#39;).name(&quot;雪天&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;snow&quot;: value &#125;); &#125;) gui.add(option, &#39;sun&#39;).name(&quot;太阳&quot;).onChange(function (value) &#123; viewer.scene.sun.show &#x3D; value; &#125;) gui.add(option, &#39;skyBox&#39;).name(&quot;星空&quot;).onChange(function (value) &#123; viewer.scene.skyBox.show &#x3D; value; &#125;) gui.add(option, &#39;globe&#39;).name(&quot;地球&quot;).onChange(function (value) &#123; viewer.scene.globe.show &#x3D; value; &#125;) gui.add(option, &#39;sbstyle&#39;).name(&quot;鼠标十字&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;sbstyle&quot;: value &#125;); &#125;) gui.add(option, &#39;depthTestAgainstTerrain&#39;).name(&quot;深度检测&quot;).onChange(function (value) &#123; viewer.scene.globe.depthTestAgainstTerrain &#x3D; value; &#125;) gui.add(option, &#39;rotation&#39;).name(&quot;地球自转&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;rotation&quot;: value &#125;); &#125;) gui.add(option, &#39;grid&#39;).name(&quot;经纬网&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;grid&quot;: &#123; &quot;cmd&quot;: 1, &quot;flag&quot;: value &#125; &#125;); &#125;) gui.add(option, &#39;tileGrid&#39;).name(&quot;标注网格&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;grid&quot;: &#123; &quot;cmd&quot;: 2, &quot;flag&quot;: value &#125; &#125;); &#125;) gui.add(option, &#39;mgrsGrid&#39;).name(&quot;军事网格&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;grid&quot;: &#123; &quot;cmd&quot;: 3, &quot;flag&quot;: value &#125; &#125;); &#125;) gui.add(option, &#39;navi&#39;).name(&quot;导航插件&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;navi&quot;: value &#125;); &#125;) gui.add(option, &#39;timeLine&#39;).name(&quot;时间轴&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;sjz&quot;: value &#125;); &#125;) gui.add(option, &#39;sbjk&#39;).name(&quot;鼠标位置&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;xjzt&quot;: value &#125;); &#125;) gui.add(option, &#39;cesiumTool&#39;).name(&quot;内置工具&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;cesiumTool&quot;: value &#125;); &#125;) gui.add(option, &#39;radar&#39;).name(&quot;全球雷达站&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;radar&quot;: value &#125;); &#125;) gui.add(option, &#39;province&#39;).name(&quot;全国省份&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;province&quot;: value &#125;); &#125;) gui.add(option, &#39;terrain&#39;).name(&quot;地形图&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;terrain&quot;: value &#125;); &#125;) gui.add(option, &#39;tiles&#39;).name(&quot;3d瓦片&quot;).onChange(function (value) &#123; sceneTree.build(&#123; &quot;_3dtiles&quot;: value &#125;); &#125;) gui.add(option, &#39;btnCut&#39;).name(&quot;截取场景&quot;); $$(&#39;.dg.ac&#39;).css(&#39;top&#39;, &#39;10%&#39;); 场景树封装：SceneTree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327&#x2F;** * @file sceneTree * @version 1.0 * sceneTree 类 * 在3d地球上挂载场景 * * *&#x2F;import &#123;CesiumTerrainProvider,EllipsoidTerrainProvider,GridImageryProvider,KmlDataSource,JulianDate,ClockRange,ClockStep,GeoJsonDataSource, Cartesian3&#125; from &#39;cesium&#39;import Rain from &#39;.&#x2F;libs&#x2F;rain&#39;;import Snow from &#39;.&#x2F;libs&#x2F;snow&#39;;let _self;export default class sceneTree &#123; constructor(core) &#123; &#x2F;** * root 节点 *&#x2F; this.root &#x3D; null; &#x2F;** * viewer *&#x2F; this.viewer &#x3D; core; &#x2F;** * 场景 *&#x2F; this.S &#x3D; core.scene; &#x2F;&#x2F;辅助对象 _self &#x3D; this; &#x2F;** * 状态码 *&#x2F; this.STATUS &#x3D; &#123; CREATE: &quot;No&quot;, CLOSE: &quot;Off&quot; &#125; &#125; &#x2F;** * build 接口 *&#x2F; build(trees) &#123; if (trees &#x3D;&#x3D; undefined) &#123; alert(&quot;没有获取到功能节点&quot;); &#125; let _self &#x3D; this; &#x2F;&#x2F;自转 if (trees.rotation !&#x3D; undefined) &#123; if (trees.rotation) &#123; this.rotation(&#123; cmd: &quot;No&quot; &#125;); &#125; else &#123; this.rotation(&#123; cmd: &quot;Off&quot; &#125;); &#125; &#125; &#x2F;&#x2F;雾天 if (trees.fog !&#x3D; undefined) &#123; this.S.fog.enabled &#x3D; trees.fog; &#125; &#x2F;&#x2F;昼夜 if (trees.lighting !&#x3D; undefined) &#123; this.S.globe.enableLighting &#x3D; trees.lighting; &#125; &#x2F;&#x2F;大气层 if (trees.groundAtmosphere !&#x3D; undefined) &#123; this.S.globe.showGroundAtmosphere &#x3D; trees.groundAtmosphere; &#125; &#x2F;&#x2F;地球 if (trees.globe !&#x3D; undefined) &#123; this.S.globe.show &#x3D; trees.globe; &#125; &#x2F;&#x2F;星空 if (trees.skyBox !&#x3D; undefined) &#123; this.S.skyBox.show &#x3D; true; &#125; &#x2F;&#x2F;太阳 if (trees.sun !&#x3D; undefined) &#123; this.S.sun.show &#x3D; trees.sun; &#125; &#x2F;&#x2F;雨天 if (trees.rain !&#x3D; undefined) &#123; if (trees.rain) &#123; setTimeout(()&#x3D;&gt; &#123; this._rain &#x3D; new Rain(this.viewer); &#125;, 100) &#125; else &#123; this._rain.remove(); &#125; &#125; &#x2F;&#x2F;雪天 if (trees.snow !&#x3D; undefined) &#123; if (trees.snow) &#123; setTimeout( ()&#x3D;&gt; &#123; this._snow&#x3D; new Snow(this.viewer); &#125;, 100) &#125; else &#123; this._snow.remove(); &#125; &#125; &#x2F;&#x2F;经纬网 if (trees.grid !&#x3D; undefined) &#123; if (1 &#x3D;&#x3D; trees.grid.cmd) &#123; if (trees.grid.flag) &#123; this.scene.grid(&#123; cmd: &quot;No&quot; &#125;); &#125; else &#123; this.scene.grid(&#123; cmd: &quot;Off&quot; &#125;); &#125; &#125; if (2 &#x3D;&#x3D; trees.grid.cmd) &#123; if (trees.grid.flag) &#123; this.scene.tileGrid(&#123; cmd: &quot;No&quot; &#125;); &#125; else &#123; this.scene.tileGrid(&#123; cmd: &quot;Off&quot; &#125;); &#125; &#125; if (3 &#x3D;&#x3D; trees.grid.cmd) &#123; if (trees.grid.flag) &#123; this.scene.mgrsGrid(&#123; cmd: &quot;No&quot; &#125;); &#125; else &#123; this.scene.mgrsGrid(&#123; cmd: &quot;Off&quot; &#125;); &#125; &#125; &#125; &#x2F;&#x2F;十字 if (trees.sbstyle !&#x3D; undefined) &#123; if (trees.sbstyle) &#123; document.documentElement.style.cursor &#x3D; &#39;crosshair&#39;; &#125; else &#123; document.documentElement.style.cursor &#x3D; &#39;default&#39;; &#125; &#125; &#x2F;&#x2F;相机状态 if (trees.xjzt !&#x3D; undefined) &#123; if (trees.xjzt) &#123; $$(&#39;.map-move-msg&#39;).show(); &#125; else &#123; $$(&#39;.map-move-msg&#39;).hide(); &#125; &#125; &#x2F;&#x2F;cesiumTool if (trees.cesiumTool !&#x3D; undefined) &#123; if (trees.cesiumTool) &#123; $$(&#39;.cesium-viewer-toolbar&#39;).show(); &#125; else &#123; $$(&#39;.cesium-viewer-toolbar&#39;).hide(); &#125; &#125; &#x2F;&#x2F;时间轴 if (trees.sjz !&#x3D; undefined) &#123; if (trees.sjz) &#123; this.showTime(); &#125; else &#123; this.hideTime(); &#125; &#125; &#x2F;&#x2F;信息框 if (trees.info !&#x3D; undefined) &#123; if (trees.info) &#123; $$(&#39;.cesium-infoBox&#39;).show(); &#125; else &#123; $$(&#39;.cesium-infoBox&#39;).hide(); &#125; &#125; &#x2F;&#x2F;导航 if (trees.navi !&#x3D; undefined) &#123; if (trees.navi) &#123; $$(&#39;.cesium-widget-cesiumNavigationContainer&#39;).show(); &#125; else &#123; $$(&#39;.cesium-widget-cesiumNavigationContainer&#39;).hide(); &#125; &#125; &#x2F;&#x2F;雷达 if (trees.radar !&#x3D; undefined) &#123; if (trees.radar) &#123; this.radar &#x3D; new Radar(&#123; viewer: this.viewer &#125;); this.radar.build(4) &#125; else &#123; if (!this.radar) return; this.radar.dmRadar.remove(); &#125; &#125; &#x2F;&#x2F;省份数据 if (trees.province !&#x3D; undefined) &#123; if (trees.province) &#123; this.createProvincesBorder(); &#125; else &#123; this.closeProvincesBorder(); &#125; &#125; &#x2F;&#x2F;3dtile if (trees._3dtiles !&#x3D; undefined) &#123; if (trees._3dtiles) &#123; this.primitive.create3DTileset(&#123; url: config.DATADIR + &#39;&#x2F;3DTiles&#x2F;building&#x2F;tileset.json&#39; &#125;); &#125; else &#123; this.primitive.remove3DTileset(); &#125; &#125; &#x2F;&#x2F;地形 if (trees.terrain !&#x3D; undefined) &#123; if (trees.terrain) &#123; try &#123; &#x2F;&#x2F;this.viewer.scene.terrainProvider &#x3D; createArcGisElevation3DTerrainProvider(Cesium); this.viewer.scene.terrainProvider &#x3D; new CesiumTerrainProvider(&#123; url: &quot;&#x2F;chinadem&#x2F;&quot; &#125;) &#125; catch (error) &#123; alert(&quot;默认地形图加载异常&quot;); &#125; &#125; else &#123; this.viewer.scene.terrainProvider &#x3D; new EllipsoidTerrainProvider(&#123;&#125;); &#125; &#125; &#125; &#x2F;** * -------- * 辅助方法 * -------- *&#x2F; &#x2F;** * 地球自转 *&#x2F; rotate() &#123; let a &#x3D; .1; let t &#x3D; Date.now(); let n &#x3D; (t - _self._rota) &#x2F; 1e3; _self._rota &#x3D; t; _self.S.camera.rotate(Cartesian3.UNIT_Z, -a * n); &#125; rotation(opt) &#123; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CREATE) &#123; _self._rota &#x3D; Date.now(); _self.CoreV.clock.onTick.addEventListener(_self.rotate); &#125; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CLOSE) &#123; _self.CoreV.clock.onTick.removeEventListener(_self.rotate); &#125; &#125; &#x2F;** * 经纬网 *&#x2F; grid(opt) &#123; let _self &#x3D; this; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CREATE) &#123; let mapGrid &#x3D; new GridImageryProvider(); _self.layerGrid &#x3D; _self.imageryLayers.addImageryProvider(mapGrid);&#x2F;&#x2F;添加注记图层 &#x2F;&#x2F;_self.imageryLayers.grid.data &#x3D; layer; _self.imageryLayers.raiseToTop(_self.layerGrid); &#x2F;&#x2F;将注记图层置顶 &#125; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CLOSE) &#123; _self.imageryLayers.remove(_self.layerGrid); &#125; &#x2F;&#x2F;return _self.layer; &#125; &#x2F;** * 经纬网2 *&#x2F; tileGrid(opt) &#123; let _self &#x3D; this; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CREATE) &#123; let mapGrid &#x3D; new TileLonlatsImageryProvider(); _self.layerTileGrid &#x3D; _self.imageryLayers.addImageryProvider(mapGrid);&#x2F;&#x2F;添加注记图层 &#x2F;&#x2F;_self.imageryLayers.grid.data &#x3D; layer; _self.imageryLayers.raiseToTop(_self.layerTileGrid); &#x2F;&#x2F;将注记图层置顶 &#125; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CLOSE) &#123; _self.imageryLayers.remove(_self.layerTileGrid); &#125; &#x2F;&#x2F; return _self.layer; &#125; &#x2F;** * 军事网格 *&#x2F; mgrsGrid(opt) &#123; let _self &#x3D; this; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CREATE) &#123; var options &#x3D; &#123; camera: this.S.camera, canvas: this.S.canvas &#125;; let pn &#x3D; KmlDataSource.load(&quot;data&#x2F;EarthPointGrid_093357.kml&quot;, options); pn.then(function (dataSource) &#123; _self.xmlData &#x3D; dataSource; _self.CoreV.dataSources.add(_self.xmlData); &#125;); &#125; if (opt.cmd &#x3D;&#x3D; _self.STATUS.CLOSE) &#123; _self.CoreV.dataSources.remove(_self.xmlData); &#125; &#x2F;&#x2F;return _self.xmlData; &#125; &#x2F;** * 日照分析 *&#x2F; &#x2F;&#x2F;显示动画时间轴 showTime() &#123; if ($$(&#39;.map-move-msg&#39;).css(&#39;display&#39;) &#x3D;&#x3D; &#39;none&#39;) &#123; $$(&#39;.cesium-viewer-animationContainer&#39;).css(&#39;bottom&#39;, 0 + &#39;px&#39;); $$(&#39;.cesium-viewer-timelineContainer&#39;).css(&#39;bottom&#39;, 0 + &#39;px&#39;); &#125; else &#123; $$(&#39;.cesium-viewer-animationContainer&#39;).css(&#39;bottom&#39;, $$(&#39;.map-move-msg&#39;).height() + &#39;px&#39;); $$(&#39;.cesium-viewer-timelineContainer&#39;).css(&#39;bottom&#39;, $$(&#39;.map-move-msg&#39;).height() + &#39;px&#39;); &#125; $$(&#39;.cesium-viewer-animationContainer&#39;).show(); $$(&#39;.cesium-viewer-timelineContainer&#39;).show(); &#125; &#x2F;&#x2F;隐藏动画时间轴 hideTime() &#123; $$(&#39;.cesium-viewer-animationContainer&#39;).hide(); $$(&#39;.cesium-viewer-timelineContainer&#39;).hide(); &#125; &#x2F;&#x2F;省份数据 createProvincesBorder() &#123; let _self &#x3D; this; var promise &#x3D; _self.viewer.dataSources.add(GeoJsonDataSource.load(config.DATADIR + &#39;&#x2F;china.json&#39;)); promise.then(function (dataSource) &#123; _self.provinceData &#x3D; dataSource; &#125;).otherwise(function (error) &#123; return new Errors(error); &#125;); &#125; &#x2F;&#x2F;清除数据 closeProvincesBorder() &#123; this.viewer.dataSources.remove(this.provinceData); &#125;&#125;","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"cesium|模拟扫描物实体功能","date":"2020-04-07T07:49:00.000Z","path":"2020/04/07/cesium-模拟扫描物实体功能/","text":"示例无人扫描示例 卫星过境示例 实现思路1.绘制圆柱体根据参数调成圆锥形状 2.加载动画czml路径 3.通过时钟对象获取当前路径点 4.将当前路径点通过 CallbackProperty 赋值给圆锥 5.路径点每次改动圆锥随之移动 代码获取路径点(移动的实体目标) 12345let cartesian &#x3D; entity.position.getValue(this.clock.currentTime);let positions &#x3D; this.mouseManager.worldToLonlat(cartesian); this.scanEntity &#x3D; this.dynamicCylinder(&#123;positions:positions,entity:entityObj,v:this.CoreV,cylinder:&#123;legnth:600000,slices:4,bottomRadius:600000&#x2F;2&#125;&#125;);this.EntityObj.push(this.entitys.add( this.scanEntity)); 传递的动态路径点 实现绑定效果(CallbackProperty) 1234567891011121314151617181920212223242526272829303132dynamicCylinder(obj) &#123; let c &#x3D; obj.cylinder; this.options &#x3D; &#123; cylinder: &#123; HeightReference: HeightReference.RELATIVE_TO_GROUND, &#x2F;&#x2F;表示相对于地形的位置。 length: c.length, &#x2F;&#x2F;长度 topRadius: 0, &#x2F;&#x2F;顶点半径 bottomRadius: c.bottomRadius, &#x2F;&#x2F;底部半径 material: new Color(0, 1, 1, .4), slices: c.slices &#125; &#125; this.positions &#x3D; obj.positions; this.entity &#x3D; obj.entity; this.v &#x3D; obj.v; var _self &#x3D; this; var _update &#x3D; function () &#123; var positions &#x3D; _self.entity.position.getValue(_self.v.clock.currentTime); var cartographic &#x3D; _self.v.scene.globe.ellipsoid.cartesianToCartographic(positions); var lat &#x3D; Math.toDegrees(cartographic.latitude) , lng &#x3D; Math.toDegrees(cartographic.longitude) , hei &#x3D; parseFloat(cartographic.height &#x2F; 4); return Cartesian3.fromDegrees(lng, lat, 0); &#125;; var _length &#x3D; function () &#123; var positions &#x3D; _self.entity.position.getValue(_self.v.clock.currentTime); var cartographic &#x3D; _self.v.scene.globe.ellipsoid.cartesianToCartographic(positions); return cartographic.height * 2; &#125; this.options.position &#x3D; new CallbackProperty(_update, false); this.options.cylinder.length &#x3D; new CallbackProperty(_length, false); &#125;","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"node|封装功能模块发布npm包","date":"2020-04-07T07:10:00.000Z","path":"2020/04/07/node-封装功能模块发布npm包/","text":"npmnpm是一个辅助前端开发的包管理工具 12345678910包括： 网站：找包、注册用户 命令行：程序员与npm交互的主要形式 仓库：最大的JavaScript软件库 管理对象：包（package） 管理方式： 增（发布：npm publish；安装：npm i） 删（废弃：npm deprecate；卸载：npm rm） 改（更新：npm up） 查（搜索：npm s） npm中涉及到的主体主要有两个：package和module，定义如下： package：含有package.json描述文件并发布到npm仓库的文件或者文件夹module：在node_modules中，可以被Node.js的require()方法加载的任何文件或文件夹可以这样理解：一个JavaScript软件，从本地发布到npm仓库时是package，从npm仓库下载到本地时就变成了module 另外，基于以上，可以看出package和module的关系： module不一定是package（比如node内置模块），package一定是module含package.json文件的module一定是package; 封装模块发布封装 注册一个npm账号 https://docs.npmjs.com/cli/publish.html 其中用户名会在发布npm包 初始化时用到 创建一个node项目并初始化 npm init依次输入信息 name 和 npm的username及password 初始化完成目录结构 准备好封装的工程文件 将功能模块集成到统一的入口文件中 测试通过… 发布npm包进入项目根目录 执行命令: npm version patch 每次发布前执行一下，避免版本冲突错误 npm publish 发布版本 查看发布的npm包 发布成功！ 调用在第三方项目中需要使用该包 执行 npm install xxmap 根据npm 的 name安装 在工程中直接调用 启动并查看效果","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"ol-cesium|疫情可视化示例","date":"2020-04-06T09:26:00.000Z","path":"2020/04/06/ol-cesium-疫情可视化示例/","text":"前言最近在github上看到ol-cesium的开源库 在ol上集成cesium支持二三维联动。目前只是简单的切换联动，存在比较多的问题。init时候同时创建23d 对性能消耗比较大。 基于丁香园的数据做了一个简单的示例 ,用的框架和都是github现成的。 效果 功能比较简单，数据接口需要替换一下 数据爬虫接口本地部署的 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;104366065 github地址：地址","tags":[{"name":"ol-cesium","slug":"ol-cesium","permalink":"http://yoursite.com/tags/ol-cesium/"}]},{"title":"ol| 基于ol+es6+webpack的开发模版","date":"2020-04-06T09:20:00.000Z","path":"2020/04/06/ol-基于ol-es6-node-webpack的开发模版/","text":"前言将之前做的业务功能整合了一下, 拆分成几个常用模块进行业务封装，使每个模块提供一个接口达到快速开发的目的。集成了多个开源插件和UI，还在完善中... 效果支持地图基本服务和封装部分业务功能 封装常用控件及功能 一套完整的sdk工具 封装常用业务模块，提供接口服务 集成标绘 风场 图表等插件 还在完善中…","tags":[{"name":"openlayers","slug":"openlayers","permalink":"http://yoursite.com/tags/openlayers/"}]},{"title":"Es6 | 异步,导出导入,编译es5详解","date":"2020-04-06T09:11:00.000Z","path":"2020/04/06/Es6-导入导出和编译es5/","text":"ES6ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 async和await这里讲一下async和await虽然是es7新出的但是用的比较多。关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。现在就看一下async-await 基本语法 123456async function basicDemo() &#123; let result &#x3D; await Math.random(); console.log(result);&#125;basicDemo(); asyncasync用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。 12345678async function demo01() &#123; return 123;&#125;demo01().then(val &#x3D;&gt; &#123; console.log(val);&#x2F;&#x2F; 123&#125;);若 async 定义的函数有返回值，return 123;相当于Promise.resolve(123),没有声明式的 return则相当于执行了Promise.resolve(); awaitawait 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 1234function notAsyncFunc() &#123; await Math.random();&#125;notAsyncFunc(); await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 1234567891011121314151617181920function sleep(second) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#39; enough sleep~&#39;); &#125;, second); &#125;)&#125;function normalFunc() &#123; console.log(&#39;normalFunc&#39;);&#125;async function awaitDemo() &#123; await normalFunc(); console.log(&#39;something, ~~&#39;); let result &#x3D; await sleep(2000); console.log(result);&#x2F;&#x2F; 两秒之后会被打印出来&#125;awaitDemo();&#x2F;&#x2F; normalFunc&#x2F;&#x2F; VM4036:13 something, ~~&#x2F;&#x2F; VM4036:15 enough sleep~ export在es6中一个文件可以默认为一个模块，模块通过export向外暴露接口，实现模块间交互等功能 相关语法 1234567891011121314151617181920212223242526export var m &#x3D; 1;&#x2F;&#x2F; 等价于var m &#x3D; 1;export &#123; m &#125; &#x2F;&#x2F; 导出多个var a &#x3D; 1;var b &#x3D; 2;var c &#x3D; 3;export &#123; a, b, c &#125;&#x2F;&#x2F; 导出对象export const student &#x3D; &#123; name: &#39;Megan&#39;, age: 18&#125;&#x2F;&#x2F; 导出函数export function add(a, b) &#123; return a + b;&#125;&#x2F;&#x2F;导出接口别名const person &#x3D; &#123; name: &#39;张呆&#39;, age: 18, gender: &quot;male&quot;&#125;export &#123; person as boy &#125; export default 12345678910111213141516171819202122232425262728293031323334353637383940export default var i &#x3D; 0;export导出语法 &#x2F;&#x2F; default exportsexport default 42;export default &#123;&#125;;export default [];export default foo;export default function () &#123;&#125;export default class &#123;&#125;export default function foo () &#123;&#125;export default class foo &#123;&#125; &#x2F;&#x2F; variables exportsexport var foo &#x3D; 1;export var foo &#x3D; function () &#123;&#125;;export var bar; &#x2F;&#x2F; lazy initializationexport let foo &#x3D; 2;export let bar; &#x2F;&#x2F; lazy initializationexport const foo &#x3D; 3;export function foo () &#123;&#125;export class foo &#123;&#125; &#x2F;&#x2F; named exportsexport &#123;foo&#125;;export &#123;foo, bar&#125;;export &#123;foo as bar&#125;;export &#123;foo as default&#125;;export &#123;foo as default, bar&#125;; &#x2F;&#x2F; exports fromexport * from &quot;foo&quot;;export &#123;foo&#125; from &quot;foo&quot;;export &#123;foo, bar&#125; from &quot;foo&quot;;export &#123;foo as bar&#125; from &quot;foo&quot;;export &#123;foo as default&#125; from &quot;foo&quot;;export &#123;foo as default, bar&#125; from &quot;foo&quot;;export &#123;default&#125; from &quot;foo&quot;;export &#123;default as foo&#125; from &quot;foo&quot;; import12345678910111213141516171819import导入语法 &#x2F;&#x2F; default importsimport foo from &quot;foo&quot;;import &#123;default as foo&#125; from &quot;foo&quot;; &#x2F;&#x2F; named importsimport &#123;bar&#125; from &quot;foo&quot;;import &#123;bar, baz&#125; from &quot;foo&quot;;import &#123;bar as baz&#125; from &quot;foo&quot;;import &#123;bar as baz, xyz&#125; from &quot;foo&quot;; &#x2F;&#x2F; glob importsimport * as foo from &quot;foo&quot;; &#x2F;&#x2F; mixing importsimport foo, &#123;baz as xyz&#125; from &quot;foo&quot;;import * as bar, &#123;baz as xyz&#125; from &quot;foo&quot;;import foo, * as bar, &#123;baz as xyz&#125; from &quot;foo&quot;; 示例 123456789101112131415161718192021注意事项导入语句只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面if(Math.random()&gt;0.5)&#123; import &#39;.&#x2F;module1.js&#39;; &#x2F;&#x2F; SyntaxError: Unexpected keyword &#39;import&#39;&#125;const import2 &#x3D; (import &#39;.&#x2F;main2.js&#39;); &#x2F;&#x2F; SyntaxErrortry&#123; import &#39;.&#x2F;module3.js&#39;; &#x2F;&#x2F; SyntaxError: Unexpected keyword &#39;import&#39;&#125;catch(err)&#123; console.error(err);&#125;const moduleNumber &#x3D; 4;import module4 from &#96;module$&#123;moduleNumber&#125;&#96;; &#x2F;&#x2F; SyntaxError: Unexpected token import 语句会被提升到文件顶部执行，也就是说在模块初始化的时候所有的 import 都必须已经导入完成import &#39;.&#x2F;module1.js&#39;;alert(&#39;code1&#39;);import module2 from &#39;.&#x2F;module2.js&#39;;alert(&#39;code2&#39;);import module3 from &#39;.&#x2F;module3.js&#39;; babel初始化工程 npm init 配置.balbelrc文件添加 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 安装依赖 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015 # react转码规则$ npm install --save-dev babel-preset-react # ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 将配置的规则加入.balbelrc 12345678&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: [] &#125; 安装babel-cli工具 1npm install --save-dev babel-cli 转换 npm run build","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"node|基于node的爬虫服务","date":"2020-04-06T09:03:00.000Z","path":"2020/04/06/node-基于node的云函数爬虫/","text":"前言爬取丁香园的数据并提供api,为界面可视化提供接口服务。 安装1234安装nodejs查看版本npm -v新建api项目 执行npm init 初始化package.json添加依赖包 执行npm install express body-parser mysql cors request --save 添加配置新建index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;* 引入express框架 *&#x2F;const express &#x3D; require(&#39;express&#39;);const app &#x3D; express(); &#x2F;* 引入cors *&#x2F;const cors &#x3D; require(&#39;cors&#39;);app.use(cors()); &#x2F;* 引入body-parser *&#x2F;const bodyParser &#x3D; require(&#39;body-parser&#39;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); &#x2F;* 引入mysql const mysql &#x3D; require(&#39;mysql&#39;);const conn &#x3D; mysql.createConnection(&#123; host: &#39;localhost&#39;, user: &#39;root&#39;, password: &#39;123456&#39;, database: &#39;test&#39;, multipleStatements: true&#125;)*&#x2F; const ncov &#x3D; require(&#39;.&#x2F;getDxyData&#39;) &#x2F;* 监听端口 *&#x2F;app.listen(8585, () &#x3D;&gt; &#123; console.log(&#39;——————————服务已启动——————————&#39;);&#125;) app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; res.send(&#39;&lt;p style&#x3D;&quot;color:red&quot;&gt;服务已启动&lt;&#x2F;p&gt;&#39;);&#125;) app.get(&#39;&#x2F;api&#x2F;getNcovData&#39;, (req, res) &#x3D;&gt; &#123; ncov.main_handler((data)&#x3D;&gt;&#123; res.json(data) &#125;)&#125;) 引入函数文件 getDxyData.js 爬取丁香园数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const request &#x3D; require(&#39;request&#39;)&#x2F;&#x2F;获取丁香园疫情数据async function getDxyData() &#123; try &#123; const body &#x3D; await new Promise( (resolve, reject) &#x3D;&gt; &#123; request(&#123; method: &#39;GET&#39;, uri: &#39;https:&#x2F;&#x2F;ncov.dxy.cn&#x2F;ncovh5&#x2F;view&#x2F;pneumonia&#39; &#125;, (error, response, body) &#x3D;&gt; &#123; if (error) return reject(error) resolve(body) &#125;) &#125; ) const statistics &#x3D; JSON.parse(&#x2F;getStatisticsService\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) const timeline &#x3D; JSON.parse(&#x2F;getTimelineService\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) const areaStatistics &#x3D; JSON.parse(&#x2F;getAreaStat\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) let listByArea &#x3D; areaStatistics.map((x) &#x3D;&gt; &#123; return &#123; provinceName: x.provinceName, provinceShortName: x.provinceShortName, tags: x.tags, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount, comment: x.comment, cities: x.cities.map((x) &#x3D;&gt; &#123; return &#123; cityName: x.cityName, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount &#125; &#125;) &#125; &#125;) let listByOther &#x3D; JSON.parse(&#x2F;getListByCountryTypeService1\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) listByOther &#x3D; listByOther.map((x) &#x3D;&gt; &#123; return &#123; provinceId: x.provinceId, provinceName: x.provinceName, provinceShortName: x.provinceShortName, tags: x.tags, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount, comment: x.comment, createTime: x.createTime, modifyTime: x.modifyTime, &#125; &#125;) return &#123; readme: &#123; source: &#39;https:&#x2F;&#x2F;ncov.dxy.cn&#x2F;ncovh5&#x2F;view&#x2F;pneumonia&#39;, statistics: &#39;数据概要&#39;, listByArea: &#39;国内数据&#39;, listByOther: &#39;国外数据&#39;, timeline: &#39;实时播报&#39; &#125;, statistics, listByArea, listByOther, timeline &#125; &#125; catch (err) &#123; return null &#125;&#125; exports.main_handler &#x3D; async (callback) &#x3D;&gt; &#123; const data &#x3D; await getDxyData() if (!data)callback(&#123; error: 1, message: &#39;加载失败，刷新再试&#39; &#125;) callback(&#123; error: 0, message: &#39;数据获取成功&#39;,data:data &#125;) &#125; 执行命令 index.js ```12打开页面访问 : &#96;&#96;&#96;http:&#x2F;&#x2F;localhost:8585&#x2F;api&#x2F;getNcovData","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"python|机器学习之随机森林算法","date":"2020-04-06T08:41:00.000Z","path":"2020/04/06/python-机器学习之随机森林算法/","text":"前言随机森林Python版本有很可以调用的库，使用随机森林非常方便，主要用到以下的库 sklearnScikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一.Sklearn 包含了很多种机器学习的方式: Classification 分类 Regression 回归 Clustering 非监督分类 Dimensionalityreduction 数据降维 Model Selection 模型选择 Preprocessing 数据预处理 Sklearn快速入门：https://www.jianshu.com/p/cd5a929bec33 numpynumpy（Numerical Python）提供了python对多维数组对象的支持：ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 numpy快速入门:https://blog.csdn.net/cxmscb/article/details/54583415 pandaspandas 是基于 Numpy 构建的含有更高级数据结构和工具的数据分析包 类似于 Numpy 的核心是 ndarray，pandas 也是围绕着 Series 和 DataFrame 两个核心数据结构展开的 。Series 和 DataFrame 分别对应于一维的序列和二维的表结构。 pandas使用教程：https://blog.csdn.net/qq_38251616/article/details/79775789 RandomForestRegressor 导入模块，创建模型 1234import matplotlib.pyplot as plt #可视化图形库import numpy as np #numpy多维数值操作库import pandas as pd #pandas数据分析库from sklearn import datasets, cross_validation, ensemble #sklearn机器学习库 引入数据，对数据进行分集 1234567&#39;&#39;&#39;加载用于回归问题的数据集 :return: 一个元组，用于回归问题。元组元素依次为：训练样本集、测试样本集、训练样本集对应的值、测试样本集对应的值 &#39;&#39;&#39; diabetes &#x3D; datasets.load_diabetes() # 使用 scikit-learn 自带的一个糖尿病病人的数据集 return cross_validation.train_test_split(diabetes.data, diabetes.target, test_size&#x3D;0.25, random_state&#x3D;0) # 拆分成训练集和测试集，测试集大小为原始数据集大小的 1&#x2F;4 模型预测 12345678910&#39;&#39;&#39; 测试 RandomForestRegressor 的用法 :param data: 可变参数。它是一个元组，这里要求其元素依次为：训练样本集、测试样本集、训练样本的 值、测试样本的值 :return: None &#39;&#39;&#39; X_train, X_test, y_train, y_test &#x3D; data regr &#x3D; ensemble.RandomForestRegressor() regr.fit(X_train, y_train) print(&quot;Traing Score:%f&quot; % regr.score(X_train, y_train)) print(&quot;Testing Score:%f&quot; % regr.score(X_test, y_test)) 训练集：0.89 测试集 ：0.24 自定义模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201# -*- coding: UTF-8 -*-import pandas as pdimport numpy as npfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.cross_validation import train_test_splitfrom sklearn.decomposition import PCAfrom sklearn import preprocessingfrom sklearn.externals import joblib# 各指数计算# PCA降维def pcachange(pcadata): global MType pcadata1 &#x3D; pcadata.fillna(0) pca &#x3D; PCA(n_components&#x3D;1) data_new &#x3D; pca.fit_transform(pcadata1) print pcadata1.columns, pca.explained_variance_ratio_ joblib.dump(pca, unicode(&#39;D:&#x2F;pca&#x2F;&#39; + str(MType) + &#39;.m&#39;, &#39;utf-8&#39;)) minmax_scaler &#x3D; preprocessing.MinMaxScaler(feature_range&#x3D;(0, 100)) joblib.dump(pca, unicode(&#39;D:&#x2F;minmax&#x2F;&#39; + str(MType) + &#39;.m&#39;, &#39;utf-8&#39;)) data_minmax &#x3D; minmax_scaler.fit_transform(data_new) return data_minmax #分组计算def cal_zs(input_features): for col in input_features: &#39;print(data[col])&#39; data_output &#x3D; data[col] data_output1 &#x3D; pcachange(data_output) data_output2 &#x3D; pd.DataFrame(data_output1) return data_output2 #整个预处理过程def preprocess(data_raw): global MType MType &#x3D; 0 info &#x3D; data_raw.iloc[:,0:12] #diannei &#x3D; data_raw.iloc[:,22:89] ylsale &#x3D;data_raw.iloc[:,-2] sale &#x3D;data_raw.iloc[:,-1] ls_features &#x3D; [[&#39;t130403&#39;,&#39;t130201&#39;,&#39;t130200&#39;,&#39;t130204&#39;,&#39;t130207&#39;,&#39;t130102&#39;,&#39;t130103&#39;,&#39;t130105&#39;,&#39;t130106&#39;,&#39;t130104&#39;,&#39;t130101&#39;]] xzl_features &#x3D; [[&#39;t200103&#39;,&#39;t200104&#39;]] yl_features &#x3D; [[&#39;t180201&#39;,&#39;t180400&#39;,&#39;t180402&#39;,&#39;t180403&#39;,&#39;t180209&#39;,&#39;t180205&#39;,&#39;t180202&#39;,&#39;t180210&#39;,&#39;t180203&#39;, &#39;t180103&#39;,&#39;t180106&#39;,&#39;t180105&#39;,&#39;t180104&#39;,&#39;t180110&#39;,&#39;t180107&#39;,&#39;t180102&#39;,&#39;t180111&#39;,&#39;t180101&#39;,&#39;t180100&#39;,&#39;t120201&#39;,&#39;t120202&#39;,&#39;t120101&#39;,&#39;t120102&#39;]] cy_features &#x3D; [[&#39;t110101&#39;,&#39;t110102&#39;,&#39;t110103&#39;,&#39;t110200&#39;,&#39;t110301&#39;,&#39;t110303&#39;,&#39;t110302&#39;]] fw_features &#x3D; [[&#39;t230224&#39;,&#39;t230212&#39;,&#39;t230206&#39;,&#39;t230213&#39;,&#39;t230230&#39;,&#39;t230223&#39;,&#39;t230129&#39;,&#39;t230112&#39;,&#39;t230125&#39;,&#39;t230107&#39;,&#39;t230126&#39;,&#39;t230100&#39;,&#39;t230103&#39;,&#39;t230108&#39;]] jy_features &#x3D; [[ &#39;t160103&#39;, &#39;t160104&#39;, &#39;t160105&#39;]] jj_features &#x3D; [ [&#39;t800000&#39;, &#39;t800001&#39;, &#39;t800010&#39;, &#39;t800011&#39;, &#39;t800012&#39;, &#39;t800013&#39;, &#39;t800014&#39;, &#39;t800020&#39;, &#39;t800030&#39;, &#39;t800031&#39;, &#39;t800032&#39;, &#39;t800035&#39;, &#39;t800036&#39;, &#39;t800037&#39;, &#39;t8_0_19&#39;, &#39;t8_0_29&#39;, &#39;t8_0_39&#39;, &#39;t8_0_49&#39;, &#39;t8_10_29&#39;, &#39;t8_10_39&#39;, &#39;t8_10_49&#39;, &#39;t8_20_39&#39;, &#39;t8_20_49&#39;, &#39;t8_30_49&#39;]] MType &#x3D; MType + 1 lszs &#x3D; cal_zs(ls_features) MType &#x3D; MType + 1 xzlzs &#x3D; cal_zs(xzl_features) MType &#x3D; MType + 1 ylzs &#x3D; cal_zs(yl_features) MType &#x3D; MType + 1 cyzs &#x3D; cal_zs(cy_features) MType &#x3D; MType + 1 fwzs &#x3D; cal_zs(fw_features) MType &#x3D; MType + 1 jyzs &#x3D; cal_zs(jy_features) MType &#x3D; MType + 1 jjzs &#x3D; cal_zs(jj_features) lszs.columns &#x3D; [&#39;lszs&#39;] xzlzs.columns &#x3D; [&#39;xzlzs&#39;] ylzs.columns &#x3D; [&#39;ylzs&#39;] cyzs.columns &#x3D; [&#39;cyzs&#39;] jyzs.columns &#x3D; [&#39;jyzs&#39;] jjzs.columns &#x3D; [&#39;jjzs&#39;] ls &#x3D; data_raw[[&#39;t130403&#39;,&#39;t130201&#39;,&#39;t130200&#39;,&#39;t130204&#39;,&#39;t130207&#39;,&#39;t130102&#39;,&#39;t130103&#39;,&#39;t130105&#39;,&#39;t130106&#39;,&#39;t130104&#39;,&#39;t130101&#39;]] cy &#x3D; data_raw[[&#39;t110101&#39;,&#39;t110102&#39;,&#39;t110103&#39;,&#39;t110200&#39;,&#39;t110301&#39;,&#39;t110303&#39;,&#39;t110302&#39;]] fw &#x3D; data_raw[[&#39;t230224&#39;,&#39;t230212&#39;,&#39;t230206&#39;,&#39;t230213&#39;,&#39;t230230&#39;,&#39;t230223&#39;,&#39;t230129&#39;,&#39;t230112&#39;,&#39;t230125&#39;,&#39;t230107&#39;,&#39;t230126&#39;,&#39;t230100&#39;,&#39;t230103&#39;,&#39;t230108&#39;]] yl &#x3D; data_raw[[&#39;t180201&#39;, &#39;t180400&#39;, &#39;t180402&#39;, &#39;t180403&#39;, &#39;t180209&#39;, &#39;t180205&#39;, &#39;t180202&#39;, &#39;t180210&#39;, &#39;t180203&#39;, &#39;t180103&#39;, &#39;t180106&#39;, &#39;t180105&#39;, &#39;t180104&#39;, &#39;t180110&#39;, &#39;t180107&#39;, &#39;t180102&#39;, &#39;t180111&#39;, &#39;t180101&#39;, &#39;t180100&#39;, &#39;t120201&#39;, &#39;t120202&#39;, &#39;t120101&#39;, &#39;t120102&#39;]] jj &#x3D; data_raw[[&#39;t800000&#39;, &#39;t800001&#39;, &#39;t800010&#39;, &#39;t800011&#39;, &#39;t800012&#39;, &#39;t800013&#39;, &#39;t800014&#39;, &#39;t800020&#39;, &#39;t800030&#39;, &#39;t800031&#39;, &#39;t800032&#39;,&#39;t800035&#39;,&#39;t800036&#39;, &#39;t800037&#39;, &#39;t8_0_19&#39;, &#39;t8_0_29&#39;, &#39;t8_0_39&#39;, &#39;t8_0_49&#39;, &#39;t8_10_29&#39;, &#39;t8_10_39&#39;, &#39;t8_10_49&#39;, &#39;t8_20_39&#39;, &#39;t8_20_49&#39;, &#39;t8_30_49&#39;]] data_pre &#x3D; pd.concat([info,lszs,xzlzs,ylzs,jyzs,ls,cy,cyzs,fw,fwzs,jjzs,jj,yl,ylsale,sale],axis &#x3D; 1) return data_pre filepath &#x3D; u&#39;D:&#x2F;data&#x2F;f1.csv&#39;labelpath &#x3D; u&#39;D:&#x2F;data&#x2F;f2.csv&#39;data &#x3D; pd.read_csv(filepath, header&#x3D;0, sep&#x3D;&#39;,&#39;,na_values&#x3D;&#39;NULL&#39;)label &#x3D; pd.read_csv(labelpath, header&#x3D;0, sep&#x3D;&#39;,&#39;) data2 &#x3D; preprocess(data)x_labels &#x3D; data2.columns[12:-2]x_labels_t &#x3D; np.array(x_labels).Tprint x_labels # 销量分等级def cat_sale(inputdata): y1 &#x3D; inputdata.iloc[:, -1] # 销量 inputdata[&#39;salecat&#39;] &#x3D; pd.qcut(y1, 10, labels&#x3D;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) inputdata[&#39;salecat&#39;] &#x3D; inputdata[&#39;salecat&#39;].astype(int) return inputdata # 随机森林算法def rt_method(x_train, y_train, x_test, y_test): global CityIndex,CityName x_train1 &#x3D; x_train.iloc[:, 12:] info_train &#x3D; x_train.iloc[:, 0:12] info_train1 &#x3D; info_train.reset_index(drop&#x3D;True) rf0 &#x3D; RandomForestRegressor(n_estimators&#x3D;100, max_features&#x3D;&#39;sqrt&#39;,oob_score&#x3D;True) x_test1 &#x3D; x_test.iloc[:, 12:] #rf0.fit(x_test1, y_test) rf0.fit(x_train1, y_train) y1 &#x3D; rf0.predict(x_train1) y_train_pred &#x3D; pd.DataFrame(y1, columns&#x3D;[&#39;cat_pred&#39;]) y_train1 &#x3D; y_train.reset_index(drop&#x3D;True) info_test &#x3D; x_test.iloc[:, 0:12] info_test1 &#x3D; info_test.reset_index(drop&#x3D;True) y2 &#x3D; rf0.predict(x_test1) y_test_pred &#x3D; pd.DataFrame(y2, columns&#x3D;[&#39;cat_pred&#39;]) y_test1 &#x3D; y_test.reset_index(drop&#x3D;True) result_train &#x3D; pd.concat([info_train1, y_train_pred, y_train1], axis&#x3D;1) result_train1 &#x3D; result_train.rename(columns&#x3D;&#123;&#39;salecat&#39;: &#39;cat_true&#39;&#125;) result_train1[&#39;PCV&#39;] &#x3D; result_train1[&#39;cat_pred&#39;] * 10 result_train1.to_csv(unicode(&#39;D:&#x2F;train.csv&#39;,&#39;utf-8&#39;), index&#x3D;False, sep&#x3D;&#39;,&#39;) result_test &#x3D; pd.concat([info_test1, y_test_pred, y_test1], axis&#x3D;1) result_test1 &#x3D; result_test.rename(columns&#x3D;&#123;&#39;salecat&#39;: &#39;cat_true&#39;&#125;) result_test1[&#39;PCV&#39;] &#x3D; result_test1[&#39;cat_pred&#39;] * 10 result_test1.to_csv(unicode(&#39;D:&#x2F;test.csv&#39;,&#39;utf-8&#39;), index&#x3D;False, sep&#x3D;&#39;,&#39;) r1 &#x3D; result_train1.cat_pred.corr(result_train1.cat_true) r2 &#x3D; result_test1.cat_pred.corr(result_test1.cat_true) print r1, r2 result.loc[CityIndex, [&#39;train_R&#39;]] &#x3D; r1 result.loc[CityIndex, [&#39;test_R&#39;]] &#x3D; r2 importances &#x3D; rf0.feature_importances_ df_ipt &#x3D; pd.DataFrame(importances, columns&#x3D;[&quot;feature_importance&quot;]) feature_imp[&quot;feature_importance&quot;] &#x3D; df_ipt return rf0 global CityName,CityIndexCityIndex &#x3D; 0feature_imp &#x3D; pd.DataFrame(data&#x3D;[])feature_imp[&#39;feature&#39;] &#x3D; x_labels_tresult &#x3D; pd.DataFrame(data&#x3D;[], index&#x3D;[], columns&#x3D;[&#39;city&#39;, &#39;train_R&#39;, &#39;test_R&#39;, &#39;num&#39;])data3 &#x3D; cat_sale(data)X &#x3D; data3.iloc[:, 0:-2]Y &#x3D; data3[&#39;salecat&#39;]Y &#x3D; Y.fillna(1)X1 &#x3D; X.fillna(0) # 用0填充空值X2 &#x3D; X1.replace(&#39;t&#39;, 1) # 用1填充t值X_train, X_test, Y_train, Y_test &#x3D; train_test_split(X2, Y, test_size&#x3D;0.3, random_state&#x3D;42)rf &#x3D; rt_method(X_train, Y_train, X_test, Y_test)joblib.dump(rf, unicode(&#39;D:&#x2F;data&#x2F;model&#x2F;0116&#x2F;ly&#x2F;全国.m&#39;, &#39;utf-8&#39;)) &#39;&#39;&#39;for city, ctdata in data3.groupby([&#39;city_name&#39;]): print city, CityIndex CityName &#x3D; city result.loc[CityIndex, [&#39;city&#39;]] &#x3D; city n &#x3D; ctdata.iloc[:, 0].size # 行数 if n &gt; 20: X &#x3D; ctdata.iloc[:, 0:-2] Y &#x3D; ctdata[&#39;salecat&#39;] Y &#x3D; Y.fillna(1) X1 &#x3D; X.fillna(0) # 用0填充空值 X2 &#x3D; X1.replace(&#39;t&#39;, 1) # 用1填充t值 X_train, X_test, Y_train, Y_test &#x3D; train_test_split(X2, Y, test_size&#x3D;0.3, random_state&#x3D;42) try: rf &#x3D; rt_method(X_train, Y_train, X_test, Y_test) joblib.dump(rf, unicode(&#39;D:&#x2F;data&#x2F;model&#x2F;0115&#x2F;ly&#x2F;&#39; + str(CityName) + &#39;.m&#39;, &#39;utf-8&#39;)) except: print (&#39;wrong&#39;) else: print n result.loc[CityIndex, [&#39;num&#39;]] &#x3D; n CityIndex &#x3D; CityIndex + 1&#39;&#39;&#39; feature_imp1 &#x3D; pd.merge(label, feature_imp, on&#x3D;&#39;feature&#39;,how &#x3D; &#39;right&#39;) result.to_csv(u&#39;D:&#x2F;R.csv&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;,encoding &#x3D; &#39;gbk&#39;)feature_imp1.to_csv(u&#39;D:&#x2F;变量重要性.csv&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;,encoding &#x3D; &#39;gbk&#39;)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"mysql|关联表字段同步","date":"2020-04-06T08:30:00.000Z","path":"2020/04/06/mysql-两张表关联字段同步字段内容/","text":"数据表表1 表2 同步把一张表中的某个字段内容同步到另一张表的字段，前提条件是两张表要有关联字段方式1: 123456update table_name1 aset a.name&#x3D; (select b.name from table_name2 b where a.oid&#x3D; b.id)where exists (select 1 from table_name2 c where a.oid&#x3D; c.id); exists用于检查子查询是否至少会返回一行数据（即exists 指定一个子查询，检测行的存在）；该子查询实际上并不返回任何数据，而是返回值True或False 方式2: 12345678910111213141516171819UPDATE table_name1 pLEFT JOIN table_name2 aON p.oid&#x3D; a.idSET a.name &#x3D; p.nameWHERE p.name !&#x3D; &#39;&#39; #############UPDATE A LEFT OUTER JOIN B ON A.ID &#x3D; B.IDLEFT OUTER JOIN C ON A.ID &#x3D; C.IDSET A.NAME &#x3D; C.NAME, A.TYPE &#x3D; B.TYPEWHERE A.ID &#x3D; #&#123;ID&#125; AND A.S_ID &#x3D; #&#123;S_ID&#125;AND A.P_ID &#x3D; #&#123;P_ID&#125;;","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"linux|CentOS6.5升级GCC","date":"2020-04-06T08:27:00.000Z","path":"2020/04/06/linux-CentOS6-5升级GCC/","text":"前言CentOS 6.5 系统自带GCC版本4.4.7 太老 在编译源码的时候经常报错unrecognized command line option “-std=c++11” 升级GCC版本安装gcc需要先安装依赖包 gmp, mpfr, mpc 安装 gmp1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;gmp&#x2F;gmp-6.1.0.tar.xztar zxf gmp-6.1.0.tar.xzcd gmp-6.1.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gmp#成功会出现configure.status文件makemake install 安装mpfr1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;mpfr&#x2F;mpfr-3.1.4.tar.gztar zxf mpfr-3.1.4.tar.gzcd mpfr-3.1.4.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;mpfx#成功会出现configure.status文件makemake install 安装 mpc1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;mpc&#x2F;mpc-1.0.3.tar.gztar zxf mpc-1.0.3.tar.gzcd mpc-1.0.3.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;mpc#成功会出现configure.status文件makemake install 下载安装gcc123456789101112wget http:&#x2F;&#x2F;mirror0.babylon.network&#x2F;gcc&#x2F;releases&#x2F;gcc-4.8.5&#x2F;gcc-4.8.5.tar.gztar zxvf gcc-4.8.5.tar.gzcd gcc-4.8.5.&#x2F;configure --help #查看帮助命令.&#x2F;configure --enable-checking&#x3D;release --enable-languages&#x3D;c,c++ --disable-multilibmake j4&#x2F;j8 #编译时间较长 -jn n代表cpu数 加快编译速度make install升级gcc动态链接库，把gcc-build-6.1.0&#x2F;stage1-x86_64-pc-linux-gnu&#x2F;libstdc++-v3&#x2F;src&#x2F;.libs&#x2F;libstdc++.so.6.0.22拷贝到&#x2F;usr&#x2F;lib64&#x2F;文件夹下，首先删除原来软连接：rm -rf libstdc++.so.6然后新建软连接,指向libstdc++.so.6.0.22:ln -s libstdc++.so.6.0.22 libstdc++.so.6运行 gcc -v 查看版本 如果还是老版本：4.4.7 12345mv &#x2F;usr&#x2F;bin&#x2F;gcc &#x2F;usr&#x2F;bin&#x2F;gcc447mv &#x2F;usr&#x2F;bin&#x2F;g++ &#x2F;usr&#x2F;bin&#x2F;g++447ln -s &#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc &#x2F;usr&#x2F;binln -s &#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;g++ &#x2F;usr&#x2F;bingcc -v","tags":[{"name":"Gcc","slug":"Gcc","permalink":"http://yoursite.com/tags/Gcc/"}]},{"title":"linux| 源码安装PostGIS","date":"2020-04-06T08:15:00.000Z","path":"2020/04/06/linux-源码安装PostGIS/","text":"准备先安装postgresql 源码安装：csdn地址 安装检查环境123rpm -qa | grep gcc-c++---如果没安装参考postgresql源码安装配置环境#安装依赖包：geos，proj，gdal，json-c，libxml2 编译 geos12345678wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;geos&#x2F;geos-3.7.0.tar.bz2 #提前下载打包tar -zxvf geos-3.7.0.tar.bz2cd geos-3.7.0.&#x2F;configure --help #查看帮助命令.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geos#成功有configure.status 文件makemake install 编译 proj1234567wget http:&#x2F;&#x2F;download.osgeo.org&#x2F;proj&#x2F;proj-5.2.0.tar.gz #提前下载打包tar -zxvf proj-5.2.0.tar.gz cd proj-5.2.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;proj#成功有configure.status 文件makemake install 编译 gdal1234567wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;gdal&#x2F;2.3.2&#x2F;gdal-2.3.2.tar.gz #提前下载打包tar -zxvf gdal-2.3.2.tar.gzcd gdal-2.3.2.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gdal --with-pg&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;bin&#x2F;pg_config#成功有configure.status 文件makemake install 编译 json-c1234567wget https:&#x2F;&#x2F;github.com&#x2F;json-c&#x2F;json-c&#x2F;archive&#x2F;json-c-0.13.1-20180305.tar.gztar -zxvf json-c-0.13.1-20180305.tar.gzcd json-c-0.13.1-20180305.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;json-c#成功有configure.status 文件makemake install 编译 libxml21234567wget https:&#x2F;&#x2F;github.com&#x2F;GNOME&#x2F;libxml2&#x2F;archive&#x2F;v2.9.7.tar.gz #提前下载打包tar -zxvf libxml2-sources-2.9.7.tar.gz cd libxml2-2.9.7.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;libxml2#成功有configure.status 文件makemake install 安装PostGis配置环境1234567891011vi &#x2F;etc&#x2F;id.so.confinclude ld.so.conf.d&#x2F;*.conf&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;lib&#x2F;usr&#x2F;local&#x2F;proj&#x2F;lib&#x2F;usr&#x2F;local&#x2F;gdal&#x2F;lib&#x2F;usr&#x2F;local&#x2F;geos&#x2F;lib&#x2F;usr&#x2F;local&#x2F;json-c&#x2F;lib&#x2F;usr&#x2F;local&#x2F;libxml2&#x2F;lib#保存ldconfig -v 下载postgis123456wget http:&#x2F;&#x2F;download.osgeo.org&#x2F;postgis&#x2F;source&#x2F;postgis-2.5.0.tar.gz #提前下载tar -zxvf postgis-2.5.0.tar.gzcd postgis-2.5.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql --with-gdalconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;gdal&#x2F;bin&#x2F;gdal-config --with-pgconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;bin&#x2F;pg_config --with-geosconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;geos&#x2F;bin&#x2F;geos-config --with-projdir&#x3D;&#x2F;usr&#x2F;local&#x2F;proj--with-xml2config&#x3D;&#x2F;usr&#x2F;local&#x2F;libxml2&#x2F;bin&#x2F;xml2-config --with-jsondir&#x3D;&#x2F;usr&#x2F;local&#x2F;json-cmakemake install postgresql 数据库安装postgis扩展1234567su -postgrespassword：create database gis_demo;\\c gis_demo;create extension postgis;CREATE EXTENSION---成功 常见错误如果出现编译错误：libmpc.so.3: cannot open shared object file: No such file or directory 参考这篇文章：csdn地址","tags":[{"name":"postgresql","slug":"postgresql","permalink":"http://yoursite.com/tags/postgresql/"}]},{"title":"Postgresql|存储过程脚本","date":"2020-04-06T08:02:00.000Z","path":"2020/04/06/Postgresql-存储过程脚本/","text":"Postgresql函数PostgreSQL函数也称为PostgreSQL存储过程。 PostgreSQL函数或存储过程是存储在数据库服务器上并可以使用SQL界面调用的一组SQL和过程语句(声明，分配，循环，控制流程等)。 它有助于您执行通常在数据库中的单个函数中进行多次查询和往返操作的操作。可以在许多语言(如SQL，PL/pgSQL，C，Python等)中创建PostgreSQL函数 12345678910CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql; 参数说明function_name 指定函数的名称。 [OR REPLACE] 是可选的，它允许您修改/替换现有函数。 RETURN 它指定要从函数返回的数据类型。它可以是基础，复合或域类型，或者也可以引用表列的类型。 function_body function_body包含可执行部分。 plpgsql 它指定实现该函数的语言的名称。 示例 对数据进行检测并打标记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CREATE OR REPLACE FUNCTION \"public\".\"pg_materules\"(varchar) RETURNS \"pg_catalog\".\"int4\" AS $BODY$ Declare tableName VARCHAR; sql VARCHAR; res int; Begin tableName:=$1; res:=0; ---- 初始化表内容 sql = 'update '||tableName||' set err_message=''异常信息:'';';execute sql; ---- ----数据表字段检查 sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''id'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''ID字段缺失,'';';execute sql; end if; sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''name'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''NAME字段缺失,'';';execute sql; end if; sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''citycode'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''CITYCODE字段缺失,'';';execute sql; end if; ---- ---- 坐标检查 ---- sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''lat'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''LAT字段缺失,'';';execute sql; else ----初始化坐标类型 sql = 'ALTER TABLE '||tableName||' ALTER COLUMN lat TYPE varchar(100);';execute sql; sql:= 'update '||tableName||' set err_message=err_message||''缺失坐标LAT,'' where lat='''' or lat is null;';execute sql; end if; sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''lon'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''LON字段缺失,'';';execute sql; else ----初始化坐标类型 sql = 'ALTER TABLE '||tableName||' ALTER COLUMN lon TYPE varchar(80);';execute sql; sql:= 'update '||tableName||' set err_message=err_message||''缺失坐标LON,'' where lon='''' or lon is null;';execute sql; end if; ---- ---- 销售额字段检查处理 ---- sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''sale'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set type_message=''空白门店'';';execute sql; else ----初始化销售额类型 sql = 'ALTER TABLE '||tableName||' ALTER COLUMN sale TYPE INT;';execute sql; sql = 'update '||tableName||' set type_message=''覆盖门店'' where type_message='''' or type_message is null;';execute sql; sql:= 'update '||tableName||' set err_message=err_message||''销售额异常,'' where sale is null or sale &lt;=0;';execute sql; end if; ---- ---- 业态检查 ---- sql:= 'select count(*) from information_schema.columns WHERE table_name = '''||tableName||''' and column_name = ''yt'';'; execute sql into res; if res is null or res=0 then sql = 'update '||tableName||' set err_message=err_message||''YT字段缺失,'';';execute sql; else sql:= 'update '||tableName||' set err_message=err_message||''缺失业态,'' where yt = '''' or yt is null;';execute sql; end if; return 0; end; $BODY$ LANGUAGE plpgsql VOLATILE COST 100 给某张表添加多个列 1234567891011121314151617181920CREATE OR REPLACE FUNCTION \"public\".\"pg_addcolumn\"(_text, varchar) RETURNS \"pg_catalog\".\"int4\" AS $BODY$ Declare cols text[]; newTableName VARCHAR; scount INTEGER; sql VARCHAR; Begin cols:=$1; newTableName:=$2; scount:= array_length(cols,1); for i in 1..scount loop sql:='alter table '||newTableName||' add column '||quote_ident(cols[i])||' VARCHAR default null;'; EXECUTE sql; end LOOP; return 0; end; $BODY$ LANGUAGE plpgsql VOLATILE COST 100 删除三个月以前的数据 12345678910CREATE OR REPLACE FUNCTION delete_ebd_compute_log_three_month_ago_data() RETURNS void AS$BODY$ begin delete from ebd_compute_log where create_time &lt; CURRENT_TIMESTAMP(0) :: TIMESTAMP WITHOUT TIME ZONE - interval '3 months'; END;$BODY$LANGUAGE plpgsql VOLATILE; GRANT EXECUTE ON FUNCTION delete_ebd_compute_log_three_month_ago_data() TO public;","tags":[{"name":"postgresql","slug":"postgresql","permalink":"http://yoursite.com/tags/postgresql/"}]},{"title":"python| socket聊天室","date":"2020-04-06T07:55:00.000Z","path":"2020/04/06/python-聊天室/","text":"服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import socketimport timeimport tkinterfrom tkinter.scrolledtext import ScrolledTextimport threadingimport requestsimport tkinterfrom socket import *from time import ctimefrom tkinter import * global Text_Show # 调用人工智能对话的函数，返回人工智能回答 def AI_Talk(s): print(s) response &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.tuling123.com&#x2F;openapi&#x2F;api&quot;, data&#x3D;&#123; &quot;key&quot;: &quot;4105cb6db8c54f5db470b6c0ee42d24b&quot;, &quot;info&quot;: s&#125;) response &#x3D; response.json() answer &#x3D; response[&#39;text&#39;] return answer # 线程二函数，用来进行对话 def Sever_Thread(sock, caddr): Text_Show.insert(&#39;end&#39;, &quot;客户端@&quot; + str(caddr[1]) + &quot;已连接!\\n&quot;) while True: # 接收数据 data &#x3D; str(sock.recv(1024).decode(&#39;UTF-8&#39;)) if data &#x3D;&#x3D; &quot;quit&quot;: Text_Show.insert(&#39;end&#39;, &quot;客户端@&quot; + str(caddr[1]) + &quot;终止了对话\\n&quot;) Text_Show.see(tkinter.END) break else: Text_Show.insert(&#39;end&#39;, &quot;来自客户端@&quot; + str(caddr[1]) + &quot;的消息为：&quot; + data + &#39;\\n&#39;) Text_Show.see(tkinter.END) # 发送数据 time.sleep(0.2) data &#x3D; AI_Talk(data) # # data &#x3D; &#39;请输入发送至客户端的数据: 123123&#39; #如果要手动输入的话就要设置好线程sleep时间不然还没有输入，就已经到其他线程了，就会发不出去。 sock.sendall(bytes(data, &#39;UTF-8&#39;)) sock.close() # 线程一函数，监听端口，一旦有客户端接入，开启线程二 def Sever_Accept(ss): while True: sock, caddr &#x3D; ss.accept() Thread2 &#x3D; threading.Thread(target&#x3D;Sever_Thread, args&#x3D;(sock, caddr)) Thread2.daemon &#x3D; True # 线程守护 Thread2.start() # 服务器初始化def Sever_Init(): HOST &#x3D; &#39;&#39; PORT &#x3D; 4700 ADDR &#x3D; (HOST, PORT) ss &#x3D; socket(AF_INET, SOCK_STREAM, 0) ss.bind(ADDR) ss.listen(20) # 允许最大监听数 Thread1 &#x3D; threading.Thread(target&#x3D;Sever_Accept, args&#x3D;(ss,)) Thread1.daemon &#x3D; True # 线程守护 Thread1.start() # 主函数 if __name__ &#x3D;&#x3D; &quot;__main__&quot;: root &#x3D; tkinter.Tk() root.title(&quot;聊天小程序服务器端 &quot;) frame1 &#x3D; Frame(root) frame1.pack() IP_Show_Label &#x3D; Label(frame1, text&#x3D;&quot;默认IP:127.0.0.1\\n默认端口为6000\\n无法更改!!!&quot;) IP_Show_Label.pack(side&#x3D;&#39;left&#39;) frame2 &#x3D; Frame(root) frame2.pack() Text_Show &#x3D; ScrolledText(frame2, width&#x3D;100, height&#x3D;30) Text_Show.bind(&quot;&lt;KeyPress&gt;&quot;, lambda e: &quot;break&quot;) Text_Show.pack(side&#x3D;&quot;bottom&quot;, fill&#x3D;&#39;both&#39;, expand&#x3D;True) Sever_Init() root.mainloop() 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import socketimport timeimport tkinterfrom tkinter.scrolledtext import ScrolledTextimport threadingimport requestsimport tkinterfrom socket import *from time import ctimefrom tkinter import * global cs, Text_Show, Send_Show # 发送按键的函数def Click_Send(): sendData &#x3D; Send_Show.get() # 获取输入内容 if sendData &#x3D;&#x3D; &#39;quit&#39;: Text_Show.insert(tkinter.END, &quot;与服务器连接已断开&quot; + &quot;\\n&quot;) Text_Show.see(tkinter.END) cs.sendall(bytes(sendData, encoding&#x3D;&quot;utf8&quot;)) cs.close() else: Text_Show.insert(tkinter.END, &quot;客户端:&quot; + sendData + &quot;\\n&quot;) Text_Show.see(tkinter.END) cs.sendall(bytes(sendData, encoding&#x3D;&quot;utf8&quot;)) Send_Show.delete(0, END) # 线程函数，循环接受客户端消息def Receive_Data(): while True: accept_data &#x3D; str(cs.recv(1024), encoding&#x3D;&quot;utf8&quot;) Text_Show.insert(tkinter.END, &quot;服务器:&quot; + accept_data + &quot;\\n&quot;) Text_Show.see(tkinter.END) # 主函数if __name__ &#x3D;&#x3D; &quot;__main__&quot;: # 初始化GUI root &#x3D; tkinter.Tk() root.title(&quot;聊天小程序客户端 &quot;) # 顶部显示部分 frame1 &#x3D; Frame(root) frame1.pack() IP_Show_Label &#x3D; Label(frame1, text&#x3D;&quot;本程序默认IP:127.0.0.1\\n默认端口为6000\\n无法更改!!!&quot;) IP_Show_Label.pack(side&#x3D;&#39;left&#39;) # 中部聊天框显示部分 frame2 &#x3D; Frame(root) frame2.pack() Text_Show &#x3D; ScrolledText(frame2, width&#x3D;70, height&#x3D;15) Text_Show.bind(&quot;&lt;KeyPress&gt;&quot;, lambda e: &quot;break&quot;) Text_Show.pack(side&#x3D;&quot;bottom&quot;, fill&#x3D;&#39;both&#39;, expand&#x3D;True) # 底部消息发送部分 frame3 &#x3D; Frame(root) frame3.pack() e3 &#x3D; StringVar() Send_Show &#x3D; Entry(frame3, textvariable&#x3D;e3, width&#x3D;60) buttontext2 &#x3D; tkinter.StringVar() buttontext2.set(&#39;发送&#39;) button_Send &#x3D; tkinter.Button(frame3, width&#x3D;10, textvariable&#x3D;buttontext2, command&#x3D;Click_Send) Send_Show.pack(side&#x3D;&quot;left&quot;) button_Send.pack(side&#x3D;&quot;left&quot;) frame3.pack() # 初始化TCP协议 HOST &#x3D; &#39;127.0.0.1&#39; PORT &#x3D; 4700 BUFSIZ &#x3D; 1024 ADDR &#x3D; (HOST, PORT) cs &#x3D; socket(AF_INET, SOCK_STREAM, 0) cs.connect(ADDR) thread &#x3D; threading.Thread(target&#x3D;Receive_Data) thread.start() root.mainloop() 效果","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"爬虫|基于redis搭建IP代理池","date":"2020-04-06T07:46:00.000Z","path":"2020/04/06/爬虫-基于redis搭建IP代理池/","text":"前言爬虫爬取网页数据时由于频繁访问会被锁定IP，返回错误响应码以及验证字母验证，可以动态使用ip代理解决。代理服务可以自己搭建，也可以购买收费的强力代理服务更靠谱。 基于redis的ip池示例： 搭建环境： 123456windows下载地址：https:&#x2F;&#x2F;github.com&#x2F;MicrosoftArchive&#x2F;redis&#x2F;releases#下载zip解压即可启动redis：运行redis-server.exe Linux安装：sudo apt-get install redis-server启动redis：运行redis-server 安装启动： 部署本地ip爬虫 12345#下载源码git clone git@github.com:jhao104&#x2F;proxy_pool.git或者直接到https:&#x2F;&#x2F;github.com&#x2F;jhao104&#x2F;proxy_pool 下载zip文件，解压出来 安装依赖： 12#进入项目目录执行pip命令 也可以手动安装pip install -r requirements.txt 配置项目： 12345678910111213141516171819202122232425262728# Config&#x2F;setting.py 为项目配置文件 # 配置DB DATABASES &#x3D; &#123; &quot;default&quot;: &#123; &quot;TYPE&quot;: &quot;SSDB&quot;, # 如果使用SSDB或redis数据库，均配置为SSDB &quot;HOST&quot;: &quot;127.0.0.1&quot;, # db host &quot;PORT&quot;: 6379, # db port redis默认6379 &quot;NAME&quot;: &quot;proxy&quot;, # 默认配置 &quot;PASSWORD&quot;: &quot;&quot; # db password &#125;&#125; # 配置 ProxyGetterPROXY_GETTER &#x3D; [ &quot;freeProxyFirst&quot;, # 这里是启用的代理抓取函数名，可在ProxyGetter&#x2F;getFreeProxy.py 扩展 &quot;freeProxySecond&quot;, ....] # 配置 API服务 SERVER_API &#x3D; &#123; &quot;HOST&quot;: &quot;0.0.0.0&quot;, # 监听ip, 0.0.0.0 监听所有IP &quot;PORT&quot;: 5010 # 监听端口&#125;#上面配置启动后，代理池访问地址为 http:&#x2F;&#x2F;127.0.0.1:5010 启动项目： 12345678# 如果你的依赖已经安全完成并且具备运行条件,可以直接在Run下运行main.py# 到Run目录下:&gt;&gt;&gt;python main.py # 如果运行成功你应该看到有4个main.py进程 # 你也可以分别运行他们,# 依次到Api下启动ProxyApi.py,Schedule下启动ProxyRefreshSchedule.py和ProxyValidSchedule.py即可. 启动查看抓取的ip：http://127.0.0.1:5010/get_all/ 项目提供内置API: 爬虫动态代理1234567891011121314151617181920212223def get_proxy(): #可以换成我的Api return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get&#x2F;&quot;).text def getURL(self, url, redirects&#x3D;False, tries_num&#x3D;6, sleep_time&#x3D;0.5, time_out&#x3D;1000, max_retry&#x3D;6, ): #从ip池动态获取一个ip proxy &#x3D; get_proxy() try: res &#x3D; requests.Session() # res &#x3D; requests.get(url,headers&#x3D;self.randHeader(), allow_redirects&#x3D;redirects, timeout&#x3D;time_out) res &#x3D; requests.get(url,headers&#x3D;self.randHeader(), allow_redirects&#x3D;redirects, timeout&#x3D;time_out, proxies&#x3D;&#123;&quot;http&quot;: &quot;http:&#x2F;&#x2F;&#123;&#125;&quot;.format(proxy), &quot;https&quot;: &quot;https:&#x2F;&#x2F;&#123;&#125;&quot;.format(proxy)&#125;) res.raise_for_status() # 如果响应状态码不是 200，就主动抛出异常 except requests.RequestException as e: sleep_time_p &#x3D; sleep_time_p + 10 time_out_p &#x3D; time_out_p + 10 tries_num_p &#x3D; tries_num_p - 1 # 设置重试次数，最大timeout 时间和 最长休眠时间 if tries_num_p &gt; 0: time.sleep(sleep_time_p) print (self.getCurrentTime(), url, &#39;URL Connection Error: 第&#39;, max_retry - tries_num_p, u&#39;次 Retry Connection&#39;, e) return self.getURL(url, &#39;False&#39;, tries_num_p, sleep_time_p, time_out_p, max_retry) return res","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"爬虫| 基于高德api接口抓取景区/小区边界数据","date":"2020-04-06T07:10:00.000Z","path":"2020/04/06/爬虫-基于高德api接口抓取景区-小区边界数据/","text":"爬虫网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 Python爬虫Python，丰富的第三方库十分强大，简单几行代码便可实现你想要的功能，更重要的，Python也是数据挖掘和分析的好能手。这样爬取数据和分析数据一条龙的服务都用Python 工作流程123456789抓取HTML页面：HTTP请求的处理： urllib, urlib2, requests 处理器的请求可以模拟浏览器发送请求，获取服务器响应的文件解析服务器相应的内容:re, xpath, BeautifulSoup(bs4), jsonpath, pyquery等使用某种描述性语言来给我们需要提取的数据定义一个匹配规则，符合这个规则的数据就会被匹配采集动态HTML，验证码的处理通用动态页面采集： Selenium + PhantomJS:模拟真实浏览器加载JS验证码处理: Tesseract机器学习库，机器图像识别系统 爬虫框架(Scrapy)Scrapy框架 : 12345678特点： 高定制性，高性能（异步网络框架twisted）-&gt;数据下载快，提供了数据存储，数据下载，提取规则等组件 分布式策略： scrapy redis：在scarpy基础上添加了以redis数据库为核心的一套组件,主要在redis做请求指纹去重、请求分配、数据临时存储爬虫、反爬虫、反反爬虫之间的斗争: User-Agent, 代理, 验证码, 动态数据加载, 加密数据 爬取高德数据边界高德api接口地址：1234567https:&#x2F;&#x2F;lbs.amap.com&#x2F;api&#x2F;webservice&#x2F;guide&#x2F;api&#x2F;search如果不是高德开发者可以申请为开发者第一步，申请”Web服务API”密钥（Key）；第二步，拼接HTTP请求URL，第一步申请的Key需作为必填参数一同发送；第三步，接收HTTP请求返回的数据（JSON或XML格式），解析数据。如无特殊声明，接口的输入参数和输出数据编码全部统一为UTF-8。 爬取思路通过高德搜索接口得到附近小区搜索列表解析后获取到正确小区的id。其中city是城市代码,可以通过浏览器手工获取到。words是搜索的具体风景区名称。 1https:&#x2F;&#x2F;restapi.amap.com&#x2F;v3&#x2F;place&#x2F;text?key&#x3D;4b86820a7590de60e4f81f53e59ae17f&amp;citylimit&#x3D;true&amp;output&#x3D;json&amp; key 为申请的密钥，申请详细步骤文档有说明keywords 查询的关键词，如景区/小区名称city 查询的目标城市 示例 ： 1https:&#x2F;&#x2F;restapi.amap.com&#x2F;v3&#x2F;place&#x2F;text?key&#x3D;4b86820a7590de60e4f81f53e59ae17f&amp;citylimit&#x3D;true&amp;output&#x3D;json&amp;keywords&#x3D;中山陵景区&amp;city&#x3D;南京 返回结果为json字符串提取景区/小区的id：B0FFHVEECG 爬取方案方案1 ：然后通过poiid调用另外一个接口查询该景区/小区 1https:&#x2F;&#x2F;ditu.amap.com&#x2F;detail&#x2F;get&#x2F;detail?id&#x3D;B0FFHVEECG 参数 id 填写上面获取到的 poiid=B0FFHVEECG 请求返回结果：将返回的结果转成json然后逐层提取出来 存入数据库或者csv文档 123456789101112def info(self, response): meta &#x3D; response.meta data &#x3D; json.loads(response.text) print(data) try: if data[&quot;status&quot;] &#x3D;&#x3D; &quot;1&quot;: spec &#x3D; data[&quot;data&quot;][&quot;spec&quot;] border &#x3D; spec[&quot;mining_shape&quot;][&quot;shape&quot;] print(&quot;border &quot;,border) AllCityDataSQL().UpdateXcJingDianiData((meta[&quot;id&quot;]),border) except: print(&quot;查询错误~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot; + meta[&quot;url&quot;]) 方案2： 通过poiid查找边界信息，红色部分可以替换成其他城市代码（身份证前6位）和景区id 接口地址：https://gaode.com/service/poiInfo?query_type=IDQ&amp;pagesize=20&amp;pagenum=1&amp;qii=true&amp;cluster_state=5&amp;need_utd=true&amp;utd_sceneid=1000&amp;div=PC1000&amp;addr_poi_merge=true&amp;is_classify=true&amp;zoom=11&amp;id=B022F0071G&amp;city=341003 请求返回结果： value字段 由一堆坐标组成的数值 123将返回的结果转成json ，然后逐层提取出来返回的value字段值还需修改一下，将_换成，才能使用存入数据库或者csv文档 常见问题高德的反扒机制： 123错误数据接口异常跳转第三方接口 推荐使用ip代理搭建一个ip池：博客 常用反反爬机制：csdn地址 PhantomJS + selenium 防反爬：csdn地址","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Java|基于springBoot的开源分布式系统","date":"2020-04-06T06:43:00.000Z","path":"2020/04/06/基于springBoot的开源分布式系统/","text":"springBoot123Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。使基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题---习惯大于约定。 四大核心1234567SpringBoot的四大核心：自动配置：针对很对spring应用程序常见的应用功能，SpringBoot能自动提供相关配置起步依赖：起步依赖和普通依赖的区别在于我们不需要传入版本号，它会根据springboot的版本号来进行依赖，解决了我们的版本不兼容性。命令行界面：这是SpringBoot的可选特性，借此 你只需要代码就能完成完整的应用程序，无需传统项目构建。（一般用于轻量级开发和测试）Actuator：是SpringBoot的一个附加功能，可以帮助你在应用程序生产环境时监视和管理应用程序。0特别对于微服务管理十分有意义。自动配置：简单的说 就是你写好代码 开启自动配置之后 springboot 会去找所有你配置好的bean 进行初始化 和 注入 等等操作 优点12345678SpringBoot主要优点：帮助开发者快速搭建Spring框架，无需配置自动整合第三方框架。帮助开发者快速启动一个web容器，内嵌servlet容器，降低了对环境的要求，可以使用命令直接执行项目，应用可用jar包执行：java -jar。继承了原有的Spring框架的优秀基因。简化了Spring的使用过程，提高了开发效率。提供了starter POM，可以非常方便 的对包进行管理，极大程度的减少了jar hell 和dependency hell。运行中对应用状态的监控。 springBoot 入门示例 ：csdn地址 iBase4j说明123456iBase4J是Java语言的分布式系统架构。 使用Spring整合开源框架。使用Maven对项目进行模块化管理，提高项目的易开发性、扩展性。系统包括4个子系统：系统管理Service、系统管理Web、业务Service、业务Web。系统管理：包括用户管理、权限管理、数据字典、系统参数管理等等。业务相关：您的业务开发。可以无限的扩展子系统，子系统之间使用Dubbo或MQ进行通信。 特点12345678910111. 数据库：Druid数据库连接池，监控数据库访问性能，统计SQL的执行性能。 数据库密码加密，加密方式请查看PropertiesUtil，decryptProperties属性配置需要解密的key。2. 持久层：mybatis持久化，使用MyBatis-Plus优化，减少sql开发量；aop切换数据库实现读写分离。Transtraction注解事务。3. MVC： 基于spring mvc注解,Rest风格Controller。Exception统一管理。4. 调度：Spring+quartz, 可以查询、修改周期、暂停、删除、新增、立即执行，查询执行记录等。5. 基于session的国际化提示信息，职责链模式的本地语言拦截器,Shiro登录、URL权限管理。会话管理，强制结束会话。6. 缓存和Session：注解redis缓存数据；shiro实现redis分布式session同步，重启服务会话不丢失。7. 多系统交互：Dubbo,ActiveMQ多系统交互，ftp&#x2F;sftp&#x2F;fastdafs发送文件到独立服务器，使文件服务分离。8. 前后端分离：没有权限的文件只用nginx代理即可。9. 日志：log4j2打印日志，业务日志和调试日志分开打印。同时基于时间和文件大小分割日志文件。10. QQ、微信、新浪微博第三方登录。11. 工具类：excel导入导出，汉字转拼音，身份证号码验证，数字转大写人民币，FTP&#x2F;SFTP&#x2F;fastDFS上传下载，发送邮件，redis缓存，加密等等。 Spring，SpringBoot，SpringMVC，Mybatis，mybatis-plus，motan/dubbo分布式，Redis缓存，Shiro权限管理，Spring-Session单点登录，Quartz分布式集群调度，Restful服务，QQ/微信登录，App token登录，微信/支付宝支付；日期转换、数据类型转换、序列化、汉字转拼音、身份证号码验证、数字转人民币、发送短信、发送邮件、加密解密、图片处理、excel导入导出、FTP/SFTP/fastDFS上传下载、二维码、XML读写、高精度计算、系统配置工具类等等 搭建GitHub地址:https://github.com/iBase4J/iBase4J-SpringBoot项目依赖：redis zookeeper actionmqredis安装：https://www.cnblogs.com/M-LittleBird/p/5902850.htmlzookeeper 安装：https://www.cnblogs.com/lsdb/p/7297731.htmlactiveMq 安装 ：https://blog.csdn.net/mr_haixin/article/details/80418204 git clone 项目 1git clone https:&#x2F;&#x2F;github.com&#x2F;iBase4J&#x2F;iBase4J-SpringBoot.git 导入开发工具 idea 配置环境 ：idea2019 jdk1.8 mysql8 导入sql文件 启动脚本 依次导入脚本 修改配置文件，配置本地环境 默认加密密码：buzhidao =,= 自定义生成密码 启动脚手架 12SysServiceApplication.java runSysWebApplication.java run Api地址访问：http://localhost:8088/swagger-ui.html#/ 访问项目还需要配置 nginx 1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; # 静态页面目录 root D:\\workspace\\iBase4J\\iBase4J-UI\\iBase4J-UI-AngularJS; # 默认首页 index index.html; location &#x3D; &#x2F; &#123; index login.html index.html index.htm; &#125; # 用户浏览器端的缓存设置 location ~* \\.(css|js|jpg|jpeg|gif|png|swf|htm|html|json|xml|svg|woff|ttf|eot|map|ico|woff2|apk)$ &#123; proxy_cache_valid 200 304 4h; expires 4h; &#125; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; location &#x2F;app&#x2F; &#123; # 动态页面,交给tomcat处理 proxy_pass http:&#x2F;&#x2F;127.0.0.1:8090; &#125; location &#x2F; &#123; # 动态页面,交给tomcat处理 proxy_pass http:&#x2F;&#x2F;127.0.0.1:8088; &#125; &#125; 搭建成功访问 ：http://localhost/admin/111111","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Java|微服务搭建","date":"2020-04-06T03:08:00.000Z","path":"2020/04/06/微服务搭建/","text":"微服务微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底去掉耦合，每一个微服务提供单个业务功能，一个服务只做一件事。从技术角度讲就是一种小而独立的处理过程，类似与进程的概念，能够自行单独启动或销毁，可以拥有自己独立的数据库 微服务框架:spring -cloud1234567891011121314Spring Cloud是一个完整的微服务解决方案，它提供分布式情况下的各种解决方案合集。而Dubbo是一款高性能的Java RPC框架。Spring Cloud生态和Dubbo生态随着技术的发展，会逐渐的融合互补总体架构 Service Provider： 暴露服务的提供方。 Service Consumer：调用远程服务的服务消费方。 EureKa Server： 服务注册中心和服务发现中心基础组件： 服务治理： Spring Cloud Eureka 客户端负载均衡： Spring Cloud Ribbon 服务容错保护： Spring Cloud Hystrix 声明式服务调用： Spring Cloud Feign API 网关服务：Spring Cloud Zuul 分布式配置中心： Spring Cloud Config spring-cloud详解: csdn地址 基于meven的spring - cloud搭建环境： 1ide工具：idea jdk版本:1.8 数据库：mysql8 工程目录： 构建父工程 新建一个空工程: File -&gt; New -&gt; New Project 创建完成有弹出框 新建modules，点击 + 号，新建一个父工程，也就是一个父 module。然后我们选择 maven 工程，选择 jdk 版本和模板，模板也可以不选择，我这里就没有选择，自己搭建即可; 在pom文件中设置spring boot的parent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;1.5.10.RELEASE&lt;/spring-boot.version&gt; &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt; &lt;mybatis.version&gt;1.3.2&lt;/mybatis.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 定义 spring cloud 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 spring boot 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 mysql 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 mybatis 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 lombok 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 父工程配置完了，子模块可以直接通过 &lt;parent&gt; 标签引用父工程的依赖包 构建common模块(公共服务模块)创建microservice-common模块（公共模块）供其子模块调用 在父工程中添加common子模块，右键microservice - new - module 123456789101112131415161718192021222324252627282930312. 在pom中添加依赖包&#96;&#96;&#96; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.demo&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&#x2F;microservice&#x2F;pom.xml&lt;&#x2F;relativePath&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;microservice-common&lt;&#x2F;artifactId&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;project&gt; 在scr/main/java/下创建实体类，添加公共实体类供其他服务调用 123456789101112131415161718192021222324252627282930313233343536373839package com.demo.springcloud.entity; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors; /** * 订单实体 *@AllArgsConstructor 注解：表示生成带有所有属性的构造方法 *@NoArgsConstructor 注解：表示生成不带参数的构方法 *@Data 注解：表示生成get和set方法 */@AllArgsConstructor@NoArgsConstructor@Datapublic class TOrder &#123; /** * 主键id */ private Long id; /** * 商品名称 */ private String name; /** * 商品价格 */ private Double price; /** * 所存的数据库名称 */ private String dbSource;&#125; 将common打包成jar文件，点击maven 分别 clean和 install一下 12345678910111213141516171819202122232425262728### 创建provider模块(服务提供者)创建服务提供者模块microservice-provider，添加方式和microservice-common一样。服务提供模块，主要负责在表中查询出订单信息，然后将信息通过接口提供给调用方，所以在该模块中，我们需要整合一下 mybatis：1. 在pom文件中配置整合的依赖包&#96;&#96;&#96;bash# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 配置application.yml 1234567891011121314151617181920# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 创建数据持久层接口 12345678910 public interface OrderMapper &#123; @Select(&quot;select * from microservice where id &#x3D; #&#123;id&#125;&quot;) TOrder findById(Long id); @Select(&quot;select * from microservice&quot;) List&lt;TOrder&gt; findAll(); &#125; 创建业务层接口以及实现类 123456789101112131415161718192021222324//业务层接口public interface OrderService &#123; TOrder findById(Long id); List&lt;TOrder&gt; findAll();&#125; //接口实现类@Servicepublic class OrderServiceImpl implements OrderService &#123; @Resource private OrderMapper orderMapper; public TOrder findById(Long id) &#123; return orderMapper.findById(id); &#125; public List&lt;TOrder&gt; findAll() &#123; return orderMapper.findAll(); &#125;&#125; 创建服务控制层 1234567891011121314151617@RestController@RequestMapping(\"/provider/order\")public class OrderProviderController &#123; @Resource private OrderService orderService; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return orderService.findById(id); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return orderService.findAll(); &#125;&#125; 创建服务启动类 123456789@SpringBootApplication@MapperScan(&quot;com.itcodai.springcloud.dao&quot;)public class OrderProvider &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderProvider.class, args); &#125;&#125; 数据结构 1服务提供者模块搭建完了可以启动测试，浏览器输入：localhost:8001&#x2F;provider&#x2F;order&#x2F;get&#x2F;list 创建consumer模块(订单消费者)新建子模块的方法和上面两个子模块一样，在命名的时候命名为 microservice-consumer 即可。 microservice-consumer 模块主要是用来调用 microservice-provider模块提供的订单信息，所以在 microservice-consumer 模块中我们不需要引入 mybatis 和 mysql 相关的依赖; 在pom文件配置依赖包 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../microservice/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservice-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的 microservice-common 通用包，可以使用common模块中的Order类 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring boot web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建RestTmplate类。在微服务都是以 HTTP 接口的形式暴露自身服务的，因此在调用远程服务时就必须使用 HTTP 客户端。Spring Boot 中使用的是 RestTemplate，首先，我们写一个配置类，将 RestTemplate 作为一个 Bean 交给 Spring 来管理 12345678@Configurationpublic class RestTmplateConfig &#123; @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 有了RestTmplate，接下来我们可以在 Controller 中注入该 RestTemplate 来调用 microservice-provider提供的服务了 12345678910111213141516171819202122//@RestController 相当于Controller注释加ResponesBody注释@RestController@RequestMapping(\"/consumer/order\")public class OrderConsumerController &#123; // 订单服务提供者模块的 url 前缀 private static final String ORDER_PROVIDER_URL_PREFIX = \"http://localhost:8001\"; @Resource private RestTemplate restTemplate; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/\" + id, TOrder.class); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/list\", List.class); &#125;&#125; 订单消费者模块搭建完了可以启动测试一下 浏览器访问： 1http:&#x2F;&#x2F;localhost:8080&#x2F;consumer&#x2F;order&#x2F;get&#x2F;list 返回结果，说明服务调用成功 可以看到通过订单消费者调用服务提供者暴露的服务，实现了每个服务专注于自身的逻辑，服务之间解耦合。 总结流程订单消费模块不直接请求数据库，而是通过 http 远程调用订单提供模块的服务来获取订单信息。也就是说，在微服务里，每个服务只关注自身的逻辑和实现，不用管其他服务的实现，需要获取某个服务的数据时，只要调用该服务提供的接口即可获取相应的数据。实现了每个服务专注于自身的逻辑，服务之间解耦合; 扩展Eureka整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88953312 Ribbon整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88977376 feign整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;89249172 微服务框架Dubbo和Spring cloud差异1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88579521 代码地址：github地址","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":" Java|设计模式总结","date":"2020-04-06T02:40:00.000Z","path":"2020/04/06/java/","text":"设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出命令模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.designpatter.demo; /**** * 设计模式 * * 命令模式 * 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通， * 这样方便将命令对象进行储存、传递、调用、增加与管理。 * * 命令模式的主要优点如下。 * 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 * 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 * 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 * 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 * * 其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 */public class CommandPatterDemo &#123; public static void main(String[] args) &#123; Context command = new Context(new read()); command.execute(); &#125; public interface Command &#123; void execute(); &#125; public static class read implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始读取数据\"); &#125; &#125; public static class copy implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始复制数据\"); &#125; &#125; public static class Context&#123; private Command command; public Context(Command command) &#123; this.command = command; &#125; public void execute()&#123; this.command.execute(); &#125; &#125;&#125; 装饰模式1234567891011121314151617181920212223242526272829303132333435363738394041package com.designpatter.demo; /** * 装饰模式 * * 介绍其适用的应用场景，装饰模式通常在以下几种情况使用。 * 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 * 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。 * 当对象的功能要求可以动态地添加，也可以再动态地撤销时。 * * 装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream， * OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、 * FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。 * */public class DecoratePatternDemo &#123; public static void main(String[] args) &#123; SuperPerson superPerson = new SuperPerson(new Person()); superPerson.eat(); &#125; static class Person&#123; public void eat()&#123; System.out.println(\"吃饭\"); &#125; &#125; static class SuperPerson&#123; private Person person; public SuperPerson(Person person) &#123; this.person = person; &#125; public void eat()&#123; System.out.println(\"喝两口\"); this.person.eat(); System.out.println(\"抽两根\"); &#125; &#125;&#125; 构建者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.designpatter.demo;/** * * 建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。 * 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 * * 该模式的主要优点如下： * 各个具体的建造者相互独立，有利于系统的扩展。 * 客户端不必知道产品内部组成的细节，便于控制细节风险。 * * 其缺点如下： * 产品的组成部分必须相同，这限制了其使用范围。 * 如果产品的内部变化复杂，该模式会增加很多的建造者类。 * * 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 * */public class WithoutPatternDemo &#123; public static void main(String[] args) &#123; Student student = new ConCreateStudent() .setSpeak1(\"test1\") .setSpeak2(\"test2\") .setSpeak3(\"test3\") .build(); System.out.println(student); &#125; public static class Student&#123; private String speak1; private String speak2; private String speak3; public void setSpeak1(String speak1) &#123; this.speak1 = speak1; &#125; public void setSpeak2(String speak2) &#123; this.speak2 = speak2; &#125; public void setSpeak3(String speak3) &#123; this.speak3 = speak3; &#125; public String getSpeak1() &#123; return speak1; &#125; public String getSpeak2() &#123; return speak2; &#125; public String getSpeak3() &#123; return speak3; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"speak1='\" + speak1 + '\\'' + \", speak2='\" + speak2 + '\\'' + \", speak3='\" + speak3 + '\\'' + '&#125;'; &#125; &#125; public interface Buidler&#123; Buidler setSpeak1(String speak1); Buidler setSpeak2(String speak2); Buidler setSpeak3(String speak3); Student build(); &#125; public static class ConCreateStudent implements Buidler &#123; Student student = new Student(); @Override public Buidler setSpeak1(String speak1) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak1(speak1); return this; &#125; @Override public Buidler setSpeak2(String speak2) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak2(speak2); return this; &#125; @Override public Buidler setSpeak3(String speak3) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak3(speak3); return this; &#125; @Override public Student build() &#123; return student; &#125; &#125;&#125; 组合模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.designpatter.demo; import java.util.ArrayList;import java.util.List;/** * 组合模式的主要优点有： * 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； * 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； * * 其主要缺点是： * 设计较复杂，客户端需要花更多时间理清类之间的层次关系； * 不容易限制容器中的构件； * 不容易用继承的方法来增加构件的新功能； * */public class WhihoutPatternDemo &#123; public static void main(String[] args) &#123; Department coreDep = new Department(\"主部门\"); Department subDep1 = new Department(\"子部门1\"); Department subDep2 = new Department(\"子部门2\"); Department leafDep1 = new Department(\"叶子部门1\"); Department leafDep2 = new Department(\"叶子部门2\"); Department leafDep3 = new Department(\"叶子部门3\"); subDep1.child.add(leafDep1); subDep2.child.add(leafDep2); subDep2.child.add(leafDep3); coreDep.child.add(subDep1); coreDep.child.add(subDep2); coreDep.remove(); &#125; static class Department&#123; private String name; private List&lt;Department&gt; child = new ArrayList&lt;Department&gt;(); public Department(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public List&lt;Department&gt; getChild() &#123; return child; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setChild(List&lt;Department&gt; child) &#123; this.child = child; &#125; void remove()&#123; if(this.child.size() &gt; 0)&#123; for(Department department:this.child)&#123; department.remove(); &#125; &#125; System.out.println(\"删除\"+name); &#125; &#125;&#125; 程序开发遵守原则1.开闭原则定义：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 作用：开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。可以提高代码的可复用性粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。可以提高软件的可维护性遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。实现：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 2.里氏替换原则定义： 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 作用： 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。实现： 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 3.依赖倒置原则定义：依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 作用： 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。实现： 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 4.单一职责原则 定义：一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 作用： 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其 他功能的影响实现:单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用. 5.接口隔离原则定义： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。作用： 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。实现： 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 6.迪米特原则 定义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 作用： 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。实现： 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 7.合成复用原则定义：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。作用： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。实现： 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用 23种设计模式 1234567891011121314151617181920212223 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 * 23种设计模式以及设计原则","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]}]