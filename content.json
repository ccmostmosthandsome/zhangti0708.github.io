[{"title":"微服务搭建","date":"2020-04-06T03:08:53.000Z","path":"2020/04/06/微服务搭建/","text":"微服务微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底去掉耦合，每一个微服务提供单个业务功能，一个服务只做一件事。从技术角度讲就是一种小而独立的处理过程，类似与进程的概念，能够自行单独启动或销毁，可以拥有自己独立的数据库 微服务框架:spring -cloud1234567891011121314Spring Cloud是一个完整的微服务解决方案，它提供分布式情况下的各种解决方案合集。而Dubbo是一款高性能的Java RPC框架。Spring Cloud生态和Dubbo生态随着技术的发展，会逐渐的融合互补总体架构 Service Provider： 暴露服务的提供方。 Service Consumer：调用远程服务的服务消费方。 EureKa Server： 服务注册中心和服务发现中心基础组件： 服务治理： Spring Cloud Eureka 客户端负载均衡： Spring Cloud Ribbon 服务容错保护： Spring Cloud Hystrix 声明式服务调用： Spring Cloud Feign API 网关服务：Spring Cloud Zuul 分布式配置中心： Spring Cloud Config spring-cloud详解: csdn地址 基于meven的spring - cloud搭建环境： 1ide工具：idea jdk版本:1.8 数据库：mysql8 工程目录： 构建父工程 新建一个空工程: File -&gt; New -&gt; New Project 创建完成有弹出框 新建modules，点击 + 号，新建一个父工程，也就是一个父 module。然后我们选择 maven 工程，选择 jdk 版本和模板，模板也可以不选择，我这里就没有选择，自己搭建即可; 在pom文件中设置spring boot的parent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;1.5.10.RELEASE&lt;/spring-boot.version&gt; &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt; &lt;mybatis.version&gt;1.3.2&lt;/mybatis.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 定义 spring cloud 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 spring boot 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 mysql 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 mybatis 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 lombok 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 父工程配置完了，子模块可以直接通过 &lt;parent&gt; 标签引用父工程的依赖包 构建common模块(公共服务模块)创建microservice-common模块（公共模块）供其子模块调用 在父工程中添加common子模块，右键microservice - new - module 123456789101112131415161718192021222324252627282930312. 在pom中添加依赖包&#96;&#96;&#96; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.demo&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&#x2F;microservice&#x2F;pom.xml&lt;&#x2F;relativePath&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;microservice-common&lt;&#x2F;artifactId&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;project&gt; 在scr/main/java/下创建实体类，添加公共实体类供其他服务调用 123456789101112131415161718192021222324252627282930313233343536373839package com.demo.springcloud.entity; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors; /** * 订单实体 *@AllArgsConstructor 注解：表示生成带有所有属性的构造方法 *@NoArgsConstructor 注解：表示生成不带参数的构方法 *@Data 注解：表示生成get和set方法 */@AllArgsConstructor@NoArgsConstructor@Datapublic class TOrder &#123; /** * 主键id */ private Long id; /** * 商品名称 */ private String name; /** * 商品价格 */ private Double price; /** * 所存的数据库名称 */ private String dbSource;&#125; 将common打包成jar文件，点击maven 分别 clean和 install一下 12345678910111213141516171819202122232425262728### 创建provider模块(服务提供者)创建服务提供者模块microservice-provider，添加方式和microservice-common一样。服务提供模块，主要负责在表中查询出订单信息，然后将信息通过接口提供给调用方，所以在该模块中，我们需要整合一下 mybatis：1. 在pom文件中配置整合的依赖包&#96;&#96;&#96;bash# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 配置application.yml 1234567891011121314151617181920# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 创建数据持久层接口 12345678910 public interface OrderMapper &#123; @Select(&quot;select * from microservice where id &#x3D; #&#123;id&#125;&quot;) TOrder findById(Long id); @Select(&quot;select * from microservice&quot;) List&lt;TOrder&gt; findAll(); &#125; 创建业务层接口以及实现类 123456789101112131415161718192021222324//业务层接口public interface OrderService &#123; TOrder findById(Long id); List&lt;TOrder&gt; findAll();&#125; //接口实现类@Servicepublic class OrderServiceImpl implements OrderService &#123; @Resource private OrderMapper orderMapper; public TOrder findById(Long id) &#123; return orderMapper.findById(id); &#125; public List&lt;TOrder&gt; findAll() &#123; return orderMapper.findAll(); &#125;&#125; 创建服务控制层 1234567891011121314151617@RestController@RequestMapping(\"/provider/order\")public class OrderProviderController &#123; @Resource private OrderService orderService; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return orderService.findById(id); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return orderService.findAll(); &#125;&#125; 创建服务启动类 123456789@SpringBootApplication@MapperScan(&quot;com.itcodai.springcloud.dao&quot;)public class OrderProvider &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderProvider.class, args); &#125;&#125; 数据结构 1服务提供者模块搭建完了可以启动测试，浏览器输入：localhost:8001&#x2F;provider&#x2F;order&#x2F;get&#x2F;list 创建consumer模块(订单消费者)新建子模块的方法和上面两个子模块一样，在命名的时候命名为 microservice-consumer 即可。 microservice-consumer 模块主要是用来调用 microservice-provider模块提供的订单信息，所以在 microservice-consumer 模块中我们不需要引入 mybatis 和 mysql 相关的依赖; 在pom文件配置依赖包 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../microservice/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservice-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的 microservice-common 通用包，可以使用common模块中的Order类 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring boot web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建RestTmplate类。在微服务都是以 HTTP 接口的形式暴露自身服务的，因此在调用远程服务时就必须使用 HTTP 客户端。Spring Boot 中使用的是 RestTemplate，首先，我们写一个配置类，将 RestTemplate 作为一个 Bean 交给 Spring 来管理 12345678@Configurationpublic class RestTmplateConfig &#123; @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 有了RestTmplate，接下来我们可以在 Controller 中注入该 RestTemplate 来调用 microservice-provider提供的服务了 12345678910111213141516171819202122//@RestController 相当于Controller注释加ResponesBody注释@RestController@RequestMapping(\"/consumer/order\")public class OrderConsumerController &#123; // 订单服务提供者模块的 url 前缀 private static final String ORDER_PROVIDER_URL_PREFIX = \"http://localhost:8001\"; @Resource private RestTemplate restTemplate; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/\" + id, TOrder.class); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/list\", List.class); &#125;&#125; 订单消费者模块搭建完了可以启动测试一下 浏览器访问： 1http:&#x2F;&#x2F;localhost:8080&#x2F;consumer&#x2F;order&#x2F;get&#x2F;list 返回结果，说明服务调用成功 可以看到通过订单消费者调用服务提供者暴露的服务，实现了每个服务专注于自身的逻辑，服务之间解耦合。 总结流程订单消费模块不直接请求数据库，而是通过 http 远程调用订单提供模块的服务来获取订单信息。也就是说，在微服务里，每个服务只关注自身的逻辑和实现，不用管其他服务的实现，需要获取某个服务的数据时，只要调用该服务提供的接口即可获取相应的数据。实现了每个服务专注于自身的逻辑，服务之间解耦合; 扩展Eureka整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88953312 Ribbon整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88977376 feign整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;89249172 微服务框架Dubbo和Spring cloud差异1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88579521 代码地址：github地址","tags":[]},{"title":" 设计模式总结","date":"2020-04-06T02:40:00.000Z","path":"2020/04/06/java/","text":"设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出命令模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.designpatter.demo; /**** * 设计模式 * * 命令模式 * 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通， * 这样方便将命令对象进行储存、传递、调用、增加与管理。 * * 命令模式的主要优点如下。 * 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 * 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 * 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 * 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 * * 其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 */public class CommandPatterDemo &#123; public static void main(String[] args) &#123; Context command = new Context(new read()); command.execute(); &#125; public interface Command &#123; void execute(); &#125; public static class read implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始读取数据\"); &#125; &#125; public static class copy implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始复制数据\"); &#125; &#125; public static class Context&#123; private Command command; public Context(Command command) &#123; this.command = command; &#125; public void execute()&#123; this.command.execute(); &#125; &#125;&#125; 装饰模式1234567891011121314151617181920212223242526272829303132333435363738394041package com.designpatter.demo; /** * 装饰模式 * * 介绍其适用的应用场景，装饰模式通常在以下几种情况使用。 * 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 * 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。 * 当对象的功能要求可以动态地添加，也可以再动态地撤销时。 * * 装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream， * OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、 * FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。 * */public class DecoratePatternDemo &#123; public static void main(String[] args) &#123; SuperPerson superPerson = new SuperPerson(new Person()); superPerson.eat(); &#125; static class Person&#123; public void eat()&#123; System.out.println(\"吃饭\"); &#125; &#125; static class SuperPerson&#123; private Person person; public SuperPerson(Person person) &#123; this.person = person; &#125; public void eat()&#123; System.out.println(\"喝两口\"); this.person.eat(); System.out.println(\"抽两根\"); &#125; &#125;&#125; 构建者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.designpatter.demo;/** * * 建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。 * 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 * * 该模式的主要优点如下： * 各个具体的建造者相互独立，有利于系统的扩展。 * 客户端不必知道产品内部组成的细节，便于控制细节风险。 * * 其缺点如下： * 产品的组成部分必须相同，这限制了其使用范围。 * 如果产品的内部变化复杂，该模式会增加很多的建造者类。 * * 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 * */public class WithoutPatternDemo &#123; public static void main(String[] args) &#123; Student student = new ConCreateStudent() .setSpeak1(\"test1\") .setSpeak2(\"test2\") .setSpeak3(\"test3\") .build(); System.out.println(student); &#125; public static class Student&#123; private String speak1; private String speak2; private String speak3; public void setSpeak1(String speak1) &#123; this.speak1 = speak1; &#125; public void setSpeak2(String speak2) &#123; this.speak2 = speak2; &#125; public void setSpeak3(String speak3) &#123; this.speak3 = speak3; &#125; public String getSpeak1() &#123; return speak1; &#125; public String getSpeak2() &#123; return speak2; &#125; public String getSpeak3() &#123; return speak3; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"speak1='\" + speak1 + '\\'' + \", speak2='\" + speak2 + '\\'' + \", speak3='\" + speak3 + '\\'' + '&#125;'; &#125; &#125; public interface Buidler&#123; Buidler setSpeak1(String speak1); Buidler setSpeak2(String speak2); Buidler setSpeak3(String speak3); Student build(); &#125; public static class ConCreateStudent implements Buidler &#123; Student student = new Student(); @Override public Buidler setSpeak1(String speak1) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak1(speak1); return this; &#125; @Override public Buidler setSpeak2(String speak2) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak2(speak2); return this; &#125; @Override public Buidler setSpeak3(String speak3) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak3(speak3); return this; &#125; @Override public Student build() &#123; return student; &#125; &#125;&#125; 组合模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.designpatter.demo; import java.util.ArrayList;import java.util.List;/** * 组合模式的主要优点有： * 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； * 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； * * 其主要缺点是： * 设计较复杂，客户端需要花更多时间理清类之间的层次关系； * 不容易限制容器中的构件； * 不容易用继承的方法来增加构件的新功能； * */public class WhihoutPatternDemo &#123; public static void main(String[] args) &#123; Department coreDep = new Department(\"主部门\"); Department subDep1 = new Department(\"子部门1\"); Department subDep2 = new Department(\"子部门2\"); Department leafDep1 = new Department(\"叶子部门1\"); Department leafDep2 = new Department(\"叶子部门2\"); Department leafDep3 = new Department(\"叶子部门3\"); subDep1.child.add(leafDep1); subDep2.child.add(leafDep2); subDep2.child.add(leafDep3); coreDep.child.add(subDep1); coreDep.child.add(subDep2); coreDep.remove(); &#125; static class Department&#123; private String name; private List&lt;Department&gt; child = new ArrayList&lt;Department&gt;(); public Department(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public List&lt;Department&gt; getChild() &#123; return child; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setChild(List&lt;Department&gt; child) &#123; this.child = child; &#125; void remove()&#123; if(this.child.size() &gt; 0)&#123; for(Department department:this.child)&#123; department.remove(); &#125; &#125; System.out.println(\"删除\"+name); &#125; &#125;&#125; 程序开发遵守原则1.开闭原则定义：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 作用：开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。可以提高代码的可复用性粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。可以提高软件的可维护性遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。实现：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 2.里氏替换原则定义： 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 作用： 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。实现： 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 3.依赖倒置原则定义：依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 作用： 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。实现： 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 4.单一职责原则 定义：一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 作用： 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其 他功能的影响实现:单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用. 5.接口隔离原则定义： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。作用： 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。实现： 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 6.迪米特原则 定义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 作用： 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。实现： 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 7.合成复用原则定义：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。作用： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。实现： 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用 23种设计模式 1234567891011121314151617181920212223 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 * 23种设计模式以及设计原则","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]}]