[{"title":"cesium|三维可视化展示","date":"2020-04-06T09:34:00.000Z","path":"2020/04/06/cesium-三维可视化展示/","text":"前言因工作需要学习cesium有一段时间了，对现有的业务功能进行模块化封装和效果展示。封装完成之后开发一套前端模版，以后项目基本可以基于这个平台做二次开发； 效果展示分为基础功能展示，分析可视化，以及业务功能模块展示 前端模版基于封装的sdk的开发模版 集成开源插件，场景控制等","tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://yoursite.com/tags/Cesium/"}]},{"title":"ol-cesium|疫情可视化示例","date":"2020-04-06T09:26:00.000Z","path":"2020/04/06/ol-cesium-疫情可视化示例/","text":"前言最近在github上看到ol-cesium的开源库 在ol上集成cesium支持二三维联动。目前只是简单的切换联动，存在比较多的问题。init时候同时创建23d 对性能消耗比较大。基于丁香园的数据做了一个简单的示例 ,用的框架和都是github现成的。 效果 功能比较简单，数据接口需要替换一下 数据爬虫接口本地部署的 1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;104366065 github地址：地址","tags":[{"name":"ol-cesium","slug":"ol-cesium","permalink":"http://yoursite.com/tags/ol-cesium/"}]},{"title":"ol| 基于ol+es6+webpack的开发模版","date":"2020-04-06T09:20:00.000Z","path":"2020/04/06/ol-基于ol-es6-node-webpack的开发模版/","text":"前言将之前做的业务功能整合了一下, 拆分成几个常用模块进行业务封装，使每个模块提供一个接口达到快速开发的目的。集成了多个开源插件和UI，还在完善中...效果支持地图基本服务和封装部分业务功能 封装常用控件及功能 一套完整的sdk工具 封装常用业务模块，提供接口服务 3.集成标绘 风场 图表等插件","tags":[{"name":"openlayers","slug":"openlayers","permalink":"http://yoursite.com/tags/openlayers/"}]},{"title":"Es6 | 语法和编译es5","date":"2020-04-06T09:11:00.000Z","path":"2020/04/06/Es6-导入导出和编译es5/","text":"ES6ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 export在es6中一个文件可以默认为一个模块，模块通过export向外暴露接口，实现模块间交互等功能 相关语法 1234567891011121314151617181920212223242526export var m &#x3D; 1;&#x2F;&#x2F; 等价于var m &#x3D; 1;export &#123; m &#125; &#x2F;&#x2F; 导出多个var a &#x3D; 1;var b &#x3D; 2;var c &#x3D; 3;export &#123; a, b, c &#125;&#x2F;&#x2F; 导出对象export const student &#x3D; &#123; name: &#39;Megan&#39;, age: 18&#125;&#x2F;&#x2F; 导出函数export function add(a, b) &#123; return a + b;&#125;&#x2F;&#x2F;导出接口别名const person &#x3D; &#123; name: &#39;张呆&#39;, age: 18, gender: &quot;male&quot;&#125;export &#123; person as boy &#125; export default 12345678910111213141516171819202122232425262728293031323334353637383940export default var i &#x3D; 0;export导出语法 &#x2F;&#x2F; default exportsexport default 42;export default &#123;&#125;;export default [];export default foo;export default function () &#123;&#125;export default class &#123;&#125;export default function foo () &#123;&#125;export default class foo &#123;&#125; &#x2F;&#x2F; variables exportsexport var foo &#x3D; 1;export var foo &#x3D; function () &#123;&#125;;export var bar; &#x2F;&#x2F; lazy initializationexport let foo &#x3D; 2;export let bar; &#x2F;&#x2F; lazy initializationexport const foo &#x3D; 3;export function foo () &#123;&#125;export class foo &#123;&#125; &#x2F;&#x2F; named exportsexport &#123;foo&#125;;export &#123;foo, bar&#125;;export &#123;foo as bar&#125;;export &#123;foo as default&#125;;export &#123;foo as default, bar&#125;; &#x2F;&#x2F; exports fromexport * from &quot;foo&quot;;export &#123;foo&#125; from &quot;foo&quot;;export &#123;foo, bar&#125; from &quot;foo&quot;;export &#123;foo as bar&#125; from &quot;foo&quot;;export &#123;foo as default&#125; from &quot;foo&quot;;export &#123;foo as default, bar&#125; from &quot;foo&quot;;export &#123;default&#125; from &quot;foo&quot;;export &#123;default as foo&#125; from &quot;foo&quot;; import12345678910111213141516171819import导入语法 &#x2F;&#x2F; default importsimport foo from &quot;foo&quot;;import &#123;default as foo&#125; from &quot;foo&quot;; &#x2F;&#x2F; named importsimport &#123;bar&#125; from &quot;foo&quot;;import &#123;bar, baz&#125; from &quot;foo&quot;;import &#123;bar as baz&#125; from &quot;foo&quot;;import &#123;bar as baz, xyz&#125; from &quot;foo&quot;; &#x2F;&#x2F; glob importsimport * as foo from &quot;foo&quot;; &#x2F;&#x2F; mixing importsimport foo, &#123;baz as xyz&#125; from &quot;foo&quot;;import * as bar, &#123;baz as xyz&#125; from &quot;foo&quot;;import foo, * as bar, &#123;baz as xyz&#125; from &quot;foo&quot;; 示例 123456789101112131415161718192021注意事项导入语句只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面if(Math.random()&gt;0.5)&#123; import &#39;.&#x2F;module1.js&#39;; &#x2F;&#x2F; SyntaxError: Unexpected keyword &#39;import&#39;&#125;const import2 &#x3D; (import &#39;.&#x2F;main2.js&#39;); &#x2F;&#x2F; SyntaxErrortry&#123; import &#39;.&#x2F;module3.js&#39;; &#x2F;&#x2F; SyntaxError: Unexpected keyword &#39;import&#39;&#125;catch(err)&#123; console.error(err);&#125;const moduleNumber &#x3D; 4;import module4 from &#96;module$&#123;moduleNumber&#125;&#96;; &#x2F;&#x2F; SyntaxError: Unexpected token import 语句会被提升到文件顶部执行，也就是说在模块初始化的时候所有的 import 都必须已经导入完成import &#39;.&#x2F;module1.js&#39;;alert(&#39;code1&#39;);import module2 from &#39;.&#x2F;module2.js&#39;;alert(&#39;code2&#39;);import module3 from &#39;.&#x2F;module3.js&#39;; babel初始化工程 npm init 配置.balbelrc文件添加 1234&#123; &quot;presets&quot;: [], &quot;plugins&quot;: []&#125; 安装依赖 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015 # react转码规则$ npm install --save-dev babel-preset-react # ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 将配置的规则加入.balbelrc 12345678&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot;, &quot;stage-2&quot; ], &quot;plugins&quot;: [] &#125; 安装babel-cli工具 1npm install --save-dev babel-cli 转换 npm run build","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"node|基于node的爬虫服务","date":"2020-04-06T09:03:00.000Z","path":"2020/04/06/node-基于node的云函数爬虫/","text":"前言爬取丁香园的数据并提供api,为界面可视化提供接口服务。 安装1234安装nodejs查看版本npm -v新建api项目 执行npm init 初始化package.json添加依赖包 执行npm install express body-parser mysql cors request --save 添加配置新建index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;* 引入express框架 *&#x2F;const express &#x3D; require(&#39;express&#39;);const app &#x3D; express(); &#x2F;* 引入cors *&#x2F;const cors &#x3D; require(&#39;cors&#39;);app.use(cors()); &#x2F;* 引入body-parser *&#x2F;const bodyParser &#x3D; require(&#39;body-parser&#39;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); &#x2F;* 引入mysql const mysql &#x3D; require(&#39;mysql&#39;);const conn &#x3D; mysql.createConnection(&#123; host: &#39;localhost&#39;, user: &#39;root&#39;, password: &#39;123456&#39;, database: &#39;test&#39;, multipleStatements: true&#125;)*&#x2F; const ncov &#x3D; require(&#39;.&#x2F;getDxyData&#39;) &#x2F;* 监听端口 *&#x2F;app.listen(8585, () &#x3D;&gt; &#123; console.log(&#39;——————————服务已启动——————————&#39;);&#125;) app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123; res.send(&#39;&lt;p style&#x3D;&quot;color:red&quot;&gt;服务已启动&lt;&#x2F;p&gt;&#39;);&#125;) app.get(&#39;&#x2F;api&#x2F;getNcovData&#39;, (req, res) &#x3D;&gt; &#123; ncov.main_handler((data)&#x3D;&gt;&#123; res.json(data) &#125;)&#125;) 引入函数文件 getDxyData.js 爬取丁香园数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const request &#x3D; require(&#39;request&#39;)&#x2F;&#x2F;获取丁香园疫情数据async function getDxyData() &#123; try &#123; const body &#x3D; await new Promise( (resolve, reject) &#x3D;&gt; &#123; request(&#123; method: &#39;GET&#39;, uri: &#39;https:&#x2F;&#x2F;ncov.dxy.cn&#x2F;ncovh5&#x2F;view&#x2F;pneumonia&#39; &#125;, (error, response, body) &#x3D;&gt; &#123; if (error) return reject(error) resolve(body) &#125;) &#125; ) const statistics &#x3D; JSON.parse(&#x2F;getStatisticsService\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) const timeline &#x3D; JSON.parse(&#x2F;getTimelineService\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) const areaStatistics &#x3D; JSON.parse(&#x2F;getAreaStat\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) let listByArea &#x3D; areaStatistics.map((x) &#x3D;&gt; &#123; return &#123; provinceName: x.provinceName, provinceShortName: x.provinceShortName, tags: x.tags, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount, comment: x.comment, cities: x.cities.map((x) &#x3D;&gt; &#123; return &#123; cityName: x.cityName, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount &#125; &#125;) &#125; &#125;) let listByOther &#x3D; JSON.parse(&#x2F;getListByCountryTypeService1\\s*&#x3D;\\s*(.*?)&#125;catch&#x2F;.exec(body)[1]) listByOther &#x3D; listByOther.map((x) &#x3D;&gt; &#123; return &#123; provinceId: x.provinceId, provinceName: x.provinceName, provinceShortName: x.provinceShortName, tags: x.tags, confirmed: x.confirmedCount, suspected: x.suspectedCount, cured: x.curedCount, dead: x.deadCount, comment: x.comment, createTime: x.createTime, modifyTime: x.modifyTime, &#125; &#125;) return &#123; readme: &#123; source: &#39;https:&#x2F;&#x2F;ncov.dxy.cn&#x2F;ncovh5&#x2F;view&#x2F;pneumonia&#39;, statistics: &#39;数据概要&#39;, listByArea: &#39;国内数据&#39;, listByOther: &#39;国外数据&#39;, timeline: &#39;实时播报&#39; &#125;, statistics, listByArea, listByOther, timeline &#125; &#125; catch (err) &#123; return null &#125;&#125; exports.main_handler &#x3D; async (callback) &#x3D;&gt; &#123; const data &#x3D; await getDxyData() if (!data)callback(&#123; error: 1, message: &#39;加载失败，刷新再试&#39; &#125;) callback(&#123; error: 0, message: &#39;数据获取成功&#39;,data:data &#125;) &#125; 执行命令 node index.js index.js ```12打开页面访问 : &#96;&#96;&#96;http:&#x2F;&#x2F;localhost:8585&#x2F;api&#x2F;getNcovData","tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"python|机器学习之随机森林算法","date":"2020-04-06T08:41:00.000Z","path":"2020/04/06/python-机器学习之随机森林算法/","text":"前言随机森林Python版本有很可以调用的库，使用随机森林非常方便，主要用到以下的库 sklearnScikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一.Sklearn 包含了很多种机器学习的方式: 分类123456789101112&#96;&#96;&#96;Regression&#96;&#96;&#96; 回归&#96;&#96;&#96;Clustering&#96;&#96;&#96; 非监督分类&#96;&#96;&#96;Dimensionalityreduction&#96;&#96;&#96; 数据降维&#96;&#96;&#96;Model Selection&#96;&#96;&#96; 模型选择&#96;&#96;&#96;Preprocessing&#96;&#96;&#96; 数据预处理Sklearn快速入门：&#96;&#96;&#96;https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;cd5a929bec33 numpynumpy（Numerical Python）提供了python对多维数组对象的支持：ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 numpy快速入门:https://blog.csdn.net/cxmscb/article/details/54583415 pandaspandas 是基于 Numpy 构建的含有更高级数据结构和工具的数据分析包 类似于 Numpy 的核心是 ndarray，pandas 也是围绕着 Series 和 DataFrame 两个核心数据结构展开的 。Series 和 DataFrame 分别对应于一维的序列和二维的表结构。 pandas使用教程：https://blog.csdn.net/qq_38251616/article/details/79775789 RandomForestRegressor 导入模块，创建模型 1234import matplotlib.pyplot as plt #可视化图形库import numpy as np #numpy多维数值操作库import pandas as pd #pandas数据分析库from sklearn import datasets, cross_validation, ensemble #sklearn机器学习库 引入数据，对数据进行分集 1234567&#39;&#39;&#39;加载用于回归问题的数据集 :return: 一个元组，用于回归问题。元组元素依次为：训练样本集、测试样本集、训练样本集对应的值、测试样本集对应的值 &#39;&#39;&#39; diabetes &#x3D; datasets.load_diabetes() # 使用 scikit-learn 自带的一个糖尿病病人的数据集 return cross_validation.train_test_split(diabetes.data, diabetes.target, test_size&#x3D;0.25, random_state&#x3D;0) # 拆分成训练集和测试集，测试集大小为原始数据集大小的 1&#x2F;4 模型预测 12345678910&#39;&#39;&#39; 测试 RandomForestRegressor 的用法 :param data: 可变参数。它是一个元组，这里要求其元素依次为：训练样本集、测试样本集、训练样本的 值、测试样本的值 :return: None &#39;&#39;&#39; X_train, X_test, y_train, y_test &#x3D; data regr &#x3D; ensemble.RandomForestRegressor() regr.fit(X_train, y_train) print(&quot;Traing Score:%f&quot; % regr.score(X_train, y_train)) print(&quot;Testing Score:%f&quot; % regr.score(X_test, y_test)) 训练集：0.89 测试集 ：0.24 自定义模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201# -*- coding: UTF-8 -*-import pandas as pdimport numpy as npfrom sklearn.ensemble import RandomForestRegressorfrom sklearn.cross_validation import train_test_splitfrom sklearn.decomposition import PCAfrom sklearn import preprocessingfrom sklearn.externals import joblib# 各指数计算# PCA降维def pcachange(pcadata): global MType pcadata1 &#x3D; pcadata.fillna(0) pca &#x3D; PCA(n_components&#x3D;1) data_new &#x3D; pca.fit_transform(pcadata1) print pcadata1.columns, pca.explained_variance_ratio_ joblib.dump(pca, unicode(&#39;D:&#x2F;pca&#x2F;&#39; + str(MType) + &#39;.m&#39;, &#39;utf-8&#39;)) minmax_scaler &#x3D; preprocessing.MinMaxScaler(feature_range&#x3D;(0, 100)) joblib.dump(pca, unicode(&#39;D:&#x2F;minmax&#x2F;&#39; + str(MType) + &#39;.m&#39;, &#39;utf-8&#39;)) data_minmax &#x3D; minmax_scaler.fit_transform(data_new) return data_minmax #分组计算def cal_zs(input_features): for col in input_features: &#39;print(data[col])&#39; data_output &#x3D; data[col] data_output1 &#x3D; pcachange(data_output) data_output2 &#x3D; pd.DataFrame(data_output1) return data_output2 #整个预处理过程def preprocess(data_raw): global MType MType &#x3D; 0 info &#x3D; data_raw.iloc[:,0:12] #diannei &#x3D; data_raw.iloc[:,22:89] ylsale &#x3D;data_raw.iloc[:,-2] sale &#x3D;data_raw.iloc[:,-1] ls_features &#x3D; [[&#39;t130403&#39;,&#39;t130201&#39;,&#39;t130200&#39;,&#39;t130204&#39;,&#39;t130207&#39;,&#39;t130102&#39;,&#39;t130103&#39;,&#39;t130105&#39;,&#39;t130106&#39;,&#39;t130104&#39;,&#39;t130101&#39;]] xzl_features &#x3D; [[&#39;t200103&#39;,&#39;t200104&#39;]] yl_features &#x3D; [[&#39;t180201&#39;,&#39;t180400&#39;,&#39;t180402&#39;,&#39;t180403&#39;,&#39;t180209&#39;,&#39;t180205&#39;,&#39;t180202&#39;,&#39;t180210&#39;,&#39;t180203&#39;, &#39;t180103&#39;,&#39;t180106&#39;,&#39;t180105&#39;,&#39;t180104&#39;,&#39;t180110&#39;,&#39;t180107&#39;,&#39;t180102&#39;,&#39;t180111&#39;,&#39;t180101&#39;,&#39;t180100&#39;,&#39;t120201&#39;,&#39;t120202&#39;,&#39;t120101&#39;,&#39;t120102&#39;]] cy_features &#x3D; [[&#39;t110101&#39;,&#39;t110102&#39;,&#39;t110103&#39;,&#39;t110200&#39;,&#39;t110301&#39;,&#39;t110303&#39;,&#39;t110302&#39;]] fw_features &#x3D; [[&#39;t230224&#39;,&#39;t230212&#39;,&#39;t230206&#39;,&#39;t230213&#39;,&#39;t230230&#39;,&#39;t230223&#39;,&#39;t230129&#39;,&#39;t230112&#39;,&#39;t230125&#39;,&#39;t230107&#39;,&#39;t230126&#39;,&#39;t230100&#39;,&#39;t230103&#39;,&#39;t230108&#39;]] jy_features &#x3D; [[ &#39;t160103&#39;, &#39;t160104&#39;, &#39;t160105&#39;]] jj_features &#x3D; [ [&#39;t800000&#39;, &#39;t800001&#39;, &#39;t800010&#39;, &#39;t800011&#39;, &#39;t800012&#39;, &#39;t800013&#39;, &#39;t800014&#39;, &#39;t800020&#39;, &#39;t800030&#39;, &#39;t800031&#39;, &#39;t800032&#39;, &#39;t800035&#39;, &#39;t800036&#39;, &#39;t800037&#39;, &#39;t8_0_19&#39;, &#39;t8_0_29&#39;, &#39;t8_0_39&#39;, &#39;t8_0_49&#39;, &#39;t8_10_29&#39;, &#39;t8_10_39&#39;, &#39;t8_10_49&#39;, &#39;t8_20_39&#39;, &#39;t8_20_49&#39;, &#39;t8_30_49&#39;]] MType &#x3D; MType + 1 lszs &#x3D; cal_zs(ls_features) MType &#x3D; MType + 1 xzlzs &#x3D; cal_zs(xzl_features) MType &#x3D; MType + 1 ylzs &#x3D; cal_zs(yl_features) MType &#x3D; MType + 1 cyzs &#x3D; cal_zs(cy_features) MType &#x3D; MType + 1 fwzs &#x3D; cal_zs(fw_features) MType &#x3D; MType + 1 jyzs &#x3D; cal_zs(jy_features) MType &#x3D; MType + 1 jjzs &#x3D; cal_zs(jj_features) lszs.columns &#x3D; [&#39;lszs&#39;] xzlzs.columns &#x3D; [&#39;xzlzs&#39;] ylzs.columns &#x3D; [&#39;ylzs&#39;] cyzs.columns &#x3D; [&#39;cyzs&#39;] jyzs.columns &#x3D; [&#39;jyzs&#39;] jjzs.columns &#x3D; [&#39;jjzs&#39;] ls &#x3D; data_raw[[&#39;t130403&#39;,&#39;t130201&#39;,&#39;t130200&#39;,&#39;t130204&#39;,&#39;t130207&#39;,&#39;t130102&#39;,&#39;t130103&#39;,&#39;t130105&#39;,&#39;t130106&#39;,&#39;t130104&#39;,&#39;t130101&#39;]] cy &#x3D; data_raw[[&#39;t110101&#39;,&#39;t110102&#39;,&#39;t110103&#39;,&#39;t110200&#39;,&#39;t110301&#39;,&#39;t110303&#39;,&#39;t110302&#39;]] fw &#x3D; data_raw[[&#39;t230224&#39;,&#39;t230212&#39;,&#39;t230206&#39;,&#39;t230213&#39;,&#39;t230230&#39;,&#39;t230223&#39;,&#39;t230129&#39;,&#39;t230112&#39;,&#39;t230125&#39;,&#39;t230107&#39;,&#39;t230126&#39;,&#39;t230100&#39;,&#39;t230103&#39;,&#39;t230108&#39;]] yl &#x3D; data_raw[[&#39;t180201&#39;, &#39;t180400&#39;, &#39;t180402&#39;, &#39;t180403&#39;, &#39;t180209&#39;, &#39;t180205&#39;, &#39;t180202&#39;, &#39;t180210&#39;, &#39;t180203&#39;, &#39;t180103&#39;, &#39;t180106&#39;, &#39;t180105&#39;, &#39;t180104&#39;, &#39;t180110&#39;, &#39;t180107&#39;, &#39;t180102&#39;, &#39;t180111&#39;, &#39;t180101&#39;, &#39;t180100&#39;, &#39;t120201&#39;, &#39;t120202&#39;, &#39;t120101&#39;, &#39;t120102&#39;]] jj &#x3D; data_raw[[&#39;t800000&#39;, &#39;t800001&#39;, &#39;t800010&#39;, &#39;t800011&#39;, &#39;t800012&#39;, &#39;t800013&#39;, &#39;t800014&#39;, &#39;t800020&#39;, &#39;t800030&#39;, &#39;t800031&#39;, &#39;t800032&#39;,&#39;t800035&#39;,&#39;t800036&#39;, &#39;t800037&#39;, &#39;t8_0_19&#39;, &#39;t8_0_29&#39;, &#39;t8_0_39&#39;, &#39;t8_0_49&#39;, &#39;t8_10_29&#39;, &#39;t8_10_39&#39;, &#39;t8_10_49&#39;, &#39;t8_20_39&#39;, &#39;t8_20_49&#39;, &#39;t8_30_49&#39;]] data_pre &#x3D; pd.concat([info,lszs,xzlzs,ylzs,jyzs,ls,cy,cyzs,fw,fwzs,jjzs,jj,yl,ylsale,sale],axis &#x3D; 1) return data_pre filepath &#x3D; u&#39;D:&#x2F;data&#x2F;f1.csv&#39;labelpath &#x3D; u&#39;D:&#x2F;data&#x2F;f2.csv&#39;data &#x3D; pd.read_csv(filepath, header&#x3D;0, sep&#x3D;&#39;,&#39;,na_values&#x3D;&#39;NULL&#39;)label &#x3D; pd.read_csv(labelpath, header&#x3D;0, sep&#x3D;&#39;,&#39;) data2 &#x3D; preprocess(data)x_labels &#x3D; data2.columns[12:-2]x_labels_t &#x3D; np.array(x_labels).Tprint x_labels # 销量分等级def cat_sale(inputdata): y1 &#x3D; inputdata.iloc[:, -1] # 销量 inputdata[&#39;salecat&#39;] &#x3D; pd.qcut(y1, 10, labels&#x3D;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) inputdata[&#39;salecat&#39;] &#x3D; inputdata[&#39;salecat&#39;].astype(int) return inputdata # 随机森林算法def rt_method(x_train, y_train, x_test, y_test): global CityIndex,CityName x_train1 &#x3D; x_train.iloc[:, 12:] info_train &#x3D; x_train.iloc[:, 0:12] info_train1 &#x3D; info_train.reset_index(drop&#x3D;True) rf0 &#x3D; RandomForestRegressor(n_estimators&#x3D;100, max_features&#x3D;&#39;sqrt&#39;,oob_score&#x3D;True) x_test1 &#x3D; x_test.iloc[:, 12:] #rf0.fit(x_test1, y_test) rf0.fit(x_train1, y_train) y1 &#x3D; rf0.predict(x_train1) y_train_pred &#x3D; pd.DataFrame(y1, columns&#x3D;[&#39;cat_pred&#39;]) y_train1 &#x3D; y_train.reset_index(drop&#x3D;True) info_test &#x3D; x_test.iloc[:, 0:12] info_test1 &#x3D; info_test.reset_index(drop&#x3D;True) y2 &#x3D; rf0.predict(x_test1) y_test_pred &#x3D; pd.DataFrame(y2, columns&#x3D;[&#39;cat_pred&#39;]) y_test1 &#x3D; y_test.reset_index(drop&#x3D;True) result_train &#x3D; pd.concat([info_train1, y_train_pred, y_train1], axis&#x3D;1) result_train1 &#x3D; result_train.rename(columns&#x3D;&#123;&#39;salecat&#39;: &#39;cat_true&#39;&#125;) result_train1[&#39;PCV&#39;] &#x3D; result_train1[&#39;cat_pred&#39;] * 10 result_train1.to_csv(unicode(&#39;D:&#x2F;train.csv&#39;,&#39;utf-8&#39;), index&#x3D;False, sep&#x3D;&#39;,&#39;) result_test &#x3D; pd.concat([info_test1, y_test_pred, y_test1], axis&#x3D;1) result_test1 &#x3D; result_test.rename(columns&#x3D;&#123;&#39;salecat&#39;: &#39;cat_true&#39;&#125;) result_test1[&#39;PCV&#39;] &#x3D; result_test1[&#39;cat_pred&#39;] * 10 result_test1.to_csv(unicode(&#39;D:&#x2F;test.csv&#39;,&#39;utf-8&#39;), index&#x3D;False, sep&#x3D;&#39;,&#39;) r1 &#x3D; result_train1.cat_pred.corr(result_train1.cat_true) r2 &#x3D; result_test1.cat_pred.corr(result_test1.cat_true) print r1, r2 result.loc[CityIndex, [&#39;train_R&#39;]] &#x3D; r1 result.loc[CityIndex, [&#39;test_R&#39;]] &#x3D; r2 importances &#x3D; rf0.feature_importances_ df_ipt &#x3D; pd.DataFrame(importances, columns&#x3D;[&quot;feature_importance&quot;]) feature_imp[&quot;feature_importance&quot;] &#x3D; df_ipt return rf0 global CityName,CityIndexCityIndex &#x3D; 0feature_imp &#x3D; pd.DataFrame(data&#x3D;[])feature_imp[&#39;feature&#39;] &#x3D; x_labels_tresult &#x3D; pd.DataFrame(data&#x3D;[], index&#x3D;[], columns&#x3D;[&#39;city&#39;, &#39;train_R&#39;, &#39;test_R&#39;, &#39;num&#39;])data3 &#x3D; cat_sale(data)X &#x3D; data3.iloc[:, 0:-2]Y &#x3D; data3[&#39;salecat&#39;]Y &#x3D; Y.fillna(1)X1 &#x3D; X.fillna(0) # 用0填充空值X2 &#x3D; X1.replace(&#39;t&#39;, 1) # 用1填充t值X_train, X_test, Y_train, Y_test &#x3D; train_test_split(X2, Y, test_size&#x3D;0.3, random_state&#x3D;42)rf &#x3D; rt_method(X_train, Y_train, X_test, Y_test)joblib.dump(rf, unicode(&#39;D:&#x2F;data&#x2F;model&#x2F;0116&#x2F;ly&#x2F;全国.m&#39;, &#39;utf-8&#39;)) &#39;&#39;&#39;for city, ctdata in data3.groupby([&#39;city_name&#39;]): print city, CityIndex CityName &#x3D; city result.loc[CityIndex, [&#39;city&#39;]] &#x3D; city n &#x3D; ctdata.iloc[:, 0].size # 行数 if n &gt; 20: X &#x3D; ctdata.iloc[:, 0:-2] Y &#x3D; ctdata[&#39;salecat&#39;] Y &#x3D; Y.fillna(1) X1 &#x3D; X.fillna(0) # 用0填充空值 X2 &#x3D; X1.replace(&#39;t&#39;, 1) # 用1填充t值 X_train, X_test, Y_train, Y_test &#x3D; train_test_split(X2, Y, test_size&#x3D;0.3, random_state&#x3D;42) try: rf &#x3D; rt_method(X_train, Y_train, X_test, Y_test) joblib.dump(rf, unicode(&#39;D:&#x2F;data&#x2F;model&#x2F;0115&#x2F;ly&#x2F;&#39; + str(CityName) + &#39;.m&#39;, &#39;utf-8&#39;)) except: print (&#39;wrong&#39;) else: print n result.loc[CityIndex, [&#39;num&#39;]] &#x3D; n CityIndex &#x3D; CityIndex + 1&#39;&#39;&#39; feature_imp1 &#x3D; pd.merge(label, feature_imp, on&#x3D;&#39;feature&#39;,how &#x3D; &#39;right&#39;) result.to_csv(u&#39;D:&#x2F;R.csv&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;,encoding &#x3D; &#39;gbk&#39;)feature_imp1.to_csv(u&#39;D:&#x2F;变量重要性.csv&#39;, index&#x3D;False, sep&#x3D;&#39;,&#39;,encoding &#x3D; &#39;gbk&#39;)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"mysql|关联表字段同步","date":"2020-04-06T08:30:00.000Z","path":"2020/04/06/mysql-两张表关联字段同步字段内容/","text":"数据表表1 表2 同步把一张表中的某个字段内容同步到另一张表的字段，前提条件是两张表要有关联字段方式1: 123456update table_name1 aset a.name&#x3D; (select b.name from table_name2 b where a.oid&#x3D; b.id)where exists (select 1 from table_name2 c where a.oid&#x3D; c.id); exists用于检查子查询是否至少会返回一行数据（即exists 指定一个子查询，检测行的存在）；该子查询实际上并不返回任何数据，而是返回值True或False 方式2: 12345678910111213141516171819UPDATE table_name1 pLEFT JOIN table_name2 aON p.oid&#x3D; a.idSET a.name &#x3D; p.nameWHERE p.name !&#x3D; &#39;&#39; #############UPDATE A LEFT OUTER JOIN B ON A.ID &#x3D; B.IDLEFT OUTER JOIN C ON A.ID &#x3D; C.IDSET A.NAME &#x3D; C.NAME, A.TYPE &#x3D; B.TYPEWHERE A.ID &#x3D; #&#123;ID&#125; AND A.S_ID &#x3D; #&#123;S_ID&#125;AND A.P_ID &#x3D; #&#123;P_ID&#125;;","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"linux|CentOS6.5升级GCC","date":"2020-04-06T08:27:00.000Z","path":"2020/04/06/linux-CentOS6-5升级GCC/","text":"前言CentOS 6.5 系统自带GCC版本4.4.7 太老 在编译源码的时候经常报错unrecognized command line option “-std=c++11” 升级GCC版本安装gcc需要先安装依赖包 gmp, mpfr, mpc 安装 gmp1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;gmp&#x2F;gmp-6.1.0.tar.xztar zxf gmp-6.1.0.tar.xzcd gmp-6.1.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gmp#成功会出现configure.status文件makemake install 安装mpfr1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;mpfr&#x2F;mpfr-3.1.4.tar.gztar zxf mpfr-3.1.4.tar.gzcd mpfr-3.1.4.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;mpfx#成功会出现configure.status文件makemake install 安装 mpc1234567wget http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;gnu&#x2F;mpc&#x2F;mpc-1.0.3.tar.gztar zxf mpc-1.0.3.tar.gzcd mpc-1.0.3.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;mpc#成功会出现configure.status文件makemake install 下载安装gcc123456789101112wget http:&#x2F;&#x2F;mirror0.babylon.network&#x2F;gcc&#x2F;releases&#x2F;gcc-4.8.5&#x2F;gcc-4.8.5.tar.gztar zxvf gcc-4.8.5.tar.gzcd gcc-4.8.5.&#x2F;configure --help #查看帮助命令.&#x2F;configure --enable-checking&#x3D;release --enable-languages&#x3D;c,c++ --disable-multilibmake j4&#x2F;j8 #编译时间较长 -jn n代表cpu数 加快编译速度make install升级gcc动态链接库，把gcc-build-6.1.0&#x2F;stage1-x86_64-pc-linux-gnu&#x2F;libstdc++-v3&#x2F;src&#x2F;.libs&#x2F;libstdc++.so.6.0.22拷贝到&#x2F;usr&#x2F;lib64&#x2F;文件夹下，首先删除原来软连接：rm -rf libstdc++.so.6然后新建软连接,指向libstdc++.so.6.0.22:ln -s libstdc++.so.6.0.22 libstdc++.so.6运行 gcc -v 查看版本 如果还是老版本：4.4.7 12345mv &#x2F;usr&#x2F;bin&#x2F;gcc &#x2F;usr&#x2F;bin&#x2F;gcc447mv &#x2F;usr&#x2F;bin&#x2F;g++ &#x2F;usr&#x2F;bin&#x2F;g++447ln -s &#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;gcc &#x2F;usr&#x2F;binln -s &#x2F;usr&#x2F;local&#x2F;gcc&#x2F;bin&#x2F;g++ &#x2F;usr&#x2F;bingcc -v","tags":[{"name":"Gcc","slug":"Gcc","permalink":"http://yoursite.com/tags/Gcc/"}]},{"title":"linux| 源码安装PostGIS","date":"2020-04-06T08:15:00.000Z","path":"2020/04/06/linux-源码安装PostGIS/","text":"准备先安装postgresql 源码安装：csdn地址 安装检查环境123rpm -qa | grep gcc-c++---如果没安装参考postgresql源码安装配置环境#安装依赖包：geos，proj，gdal，json-c，libxml2 编译 geos12345678wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;geos&#x2F;geos-3.7.0.tar.bz2 #提前下载打包tar -zxvf geos-3.7.0.tar.bz2cd geos-3.7.0.&#x2F;configure --help #查看帮助命令.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geos#成功有configure.status 文件makemake install 编译 proj1234567wget http:&#x2F;&#x2F;download.osgeo.org&#x2F;proj&#x2F;proj-5.2.0.tar.gz #提前下载打包tar -zxvf proj-5.2.0.tar.gz cd proj-5.2.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;proj#成功有configure.status 文件makemake install 编译 gdal1234567wget https:&#x2F;&#x2F;download.osgeo.org&#x2F;gdal&#x2F;2.3.2&#x2F;gdal-2.3.2.tar.gz #提前下载打包tar -zxvf gdal-2.3.2.tar.gzcd gdal-2.3.2.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;gdal --with-pg&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;bin&#x2F;pg_config#成功有configure.status 文件makemake install 编译 json-c1234567wget https:&#x2F;&#x2F;github.com&#x2F;json-c&#x2F;json-c&#x2F;archive&#x2F;json-c-0.13.1-20180305.tar.gztar -zxvf json-c-0.13.1-20180305.tar.gzcd json-c-0.13.1-20180305.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;json-c#成功有configure.status 文件makemake install 编译 libxml21234567wget https:&#x2F;&#x2F;github.com&#x2F;GNOME&#x2F;libxml2&#x2F;archive&#x2F;v2.9.7.tar.gz #提前下载打包tar -zxvf libxml2-sources-2.9.7.tar.gz cd libxml2-2.9.7.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;libxml2#成功有configure.status 文件makemake install 安装PostGis配置环境1234567891011vi &#x2F;etc&#x2F;id.so.confinclude ld.so.conf.d&#x2F;*.conf&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;lib&#x2F;usr&#x2F;local&#x2F;proj&#x2F;lib&#x2F;usr&#x2F;local&#x2F;gdal&#x2F;lib&#x2F;usr&#x2F;local&#x2F;geos&#x2F;lib&#x2F;usr&#x2F;local&#x2F;json-c&#x2F;lib&#x2F;usr&#x2F;local&#x2F;libxml2&#x2F;lib#保存ldconfig -v 下载postgis123456wget http:&#x2F;&#x2F;download.osgeo.org&#x2F;postgis&#x2F;source&#x2F;postgis-2.5.0.tar.gz #提前下载tar -zxvf postgis-2.5.0.tar.gzcd postgis-2.5.0.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql --with-gdalconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;gdal&#x2F;bin&#x2F;gdal-config --with-pgconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;bin&#x2F;pg_config --with-geosconfig&#x3D;&#x2F;usr&#x2F;local&#x2F;geos&#x2F;bin&#x2F;geos-config --with-projdir&#x3D;&#x2F;usr&#x2F;local&#x2F;proj--with-xml2config&#x3D;&#x2F;usr&#x2F;local&#x2F;libxml2&#x2F;bin&#x2F;xml2-config --with-jsondir&#x3D;&#x2F;usr&#x2F;local&#x2F;json-cmakemake install postgresql 数据库安装postgis扩展1234567su -postgrespassword：create database gis_demo;\\c gis_demo;create extension postgis;CREATE EXTENSION---成功 常见错误如果出现编译错误：libmpc.so.3: cannot open shared object file: No such file or directory 参考这篇文章：csdn地址","tags":[{"name":"postgresql","slug":"postgresql","permalink":"http://yoursite.com/tags/postgresql/"}]},{"title":"Postgresql|存储过程脚本","date":"2020-04-06T08:02:00.000Z","path":"2020/04/06/Postgresql-存储过程脚本/","text":"Postgresql函数PostgreSQL函数也称为PostgreSQL存储过程。 PostgreSQL函数或存储过程是存储在数据库服务器上并可以使用SQL界面调用的一组SQL和过程语句(声明，分配，循环，控制流程等)。 它有助于您执行通常在数据库中的单个函数中进行多次查询和往返操作的操作。可以在许多语言(如SQL，PL/pgSQL，C，Python等)中创建PostgreSQL函数 12345678910CREATE [OR REPLACE] FUNCTION function_name (arguments) RETURNS return_datatype AS $variable_name$ DECLARE declaration; [...] BEGIN &lt; function_body &gt; [...] RETURN &#123; variable_name | value &#125; END; LANGUAGE plpgsql; 参数说明指定函数的名称。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#96;&#96;&#96;[OR REPLACE]&#96;&#96;&#96; 是可选的，它允许您修改&#x2F;替换现有函数。&#96;&#96;&#96;RETURN&#96;&#96;&#96; 它指定要从函数返回的数据类型。它可以是基础，复合或域类型，或者也可以引用表列的类型。&#96;&#96;&#96;function_body&#96;&#96;&#96; function_body包含可执行部分。&#96;&#96;&#96;plpgsql&#96;&#96;&#96; 它指定实现该函数的语言的名称。### 示例1. 对数据进行检测并打标记&#96;&#96;&#96;bashCREATE OR REPLACE FUNCTION &quot;public&quot;.&quot;pg_materules&quot;(varchar) RETURNS &quot;pg_catalog&quot;.&quot;int4&quot; AS $BODY$ Declare tableName VARCHAR; sql VARCHAR; res int; Begin tableName:&#x3D;$1; res:&#x3D;0; ---- 初始化表内容 sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;&#39;&#39;异常信息:&#39;&#39;;&#39;;execute sql; ---- ----数据表字段检查 sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;id&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;ID字段缺失,&#39;&#39;;&#39;;execute sql; end if; sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;name&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;NAME字段缺失,&#39;&#39;;&#39;;execute sql; end if; sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;citycode&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;CITYCODE字段缺失,&#39;&#39;;&#39;;execute sql; end if; ---- ---- 坐标检查 ---- sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;lat&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;LAT字段缺失,&#39;&#39;;&#39;;execute sql; else ----初始化坐标类型 sql &#x3D; &#39;ALTER TABLE &#39;||tableName||&#39; ALTER COLUMN lat TYPE varchar(100);&#39;;execute sql; sql:&#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;缺失坐标LAT,&#39;&#39; where lat&#x3D;&#39;&#39;&#39;&#39; or lat is null;&#39;;execute sql; end if; sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;lon&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;LON字段缺失,&#39;&#39;;&#39;;execute sql; else ----初始化坐标类型 sql &#x3D; &#39;ALTER TABLE &#39;||tableName||&#39; ALTER COLUMN lon TYPE varchar(80);&#39;;execute sql; sql:&#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;缺失坐标LON,&#39;&#39; where lon&#x3D;&#39;&#39;&#39;&#39; or lon is null;&#39;;execute sql; end if; ---- ---- 销售额字段检查处理 ---- sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;sale&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set type_message&#x3D;&#39;&#39;空白门店&#39;&#39;;&#39;;execute sql; else ----初始化销售额类型 sql &#x3D; &#39;ALTER TABLE &#39;||tableName||&#39; ALTER COLUMN sale TYPE INT;&#39;;execute sql; sql &#x3D; &#39;update &#39;||tableName||&#39; set type_message&#x3D;&#39;&#39;覆盖门店&#39;&#39; where type_message&#x3D;&#39;&#39;&#39;&#39; or type_message is null;&#39;;execute sql; sql:&#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;销售额异常,&#39;&#39; where sale is null or sale &lt;&#x3D;0;&#39;;execute sql; end if; ---- ---- 业态检查 ---- sql:&#x3D; &#39;select count(*) from information_schema.columns WHERE table_name &#x3D; &#39;&#39;&#39;||tableName||&#39;&#39;&#39; and column_name &#x3D; &#39;&#39;yt&#39;&#39;;&#39;; execute sql into res; if res is null or res&#x3D;0 then sql &#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;YT字段缺失,&#39;&#39;;&#39;;execute sql; else sql:&#x3D; &#39;update &#39;||tableName||&#39; set err_message&#x3D;err_message||&#39;&#39;缺失业态,&#39;&#39; where yt &#x3D; &#39;&#39;&#39;&#39; or yt is null;&#39;;execute sql; end if; return 0; end; $BODY$ LANGUAGE plpgsql VOLATILE COST 100 给某张表添加多个列 1234567891011121314151617181920CREATE OR REPLACE FUNCTION \"public\".\"pg_addcolumn\"(_text, varchar) RETURNS \"pg_catalog\".\"int4\" AS $BODY$ Declare cols text[]; newTableName VARCHAR; scount INTEGER; sql VARCHAR; Begin cols:=$1; newTableName:=$2; scount:= array_length(cols,1); for i in 1..scount loop sql:='alter table '||newTableName||' add column '||quote_ident(cols[i])||' VARCHAR default null;'; EXECUTE sql; end LOOP; return 0; end; $BODY$ LANGUAGE plpgsql VOLATILE COST 100 删除三个月以前的数据 12345678910CREATE OR REPLACE FUNCTION delete_ebd_compute_log_three_month_ago_data() RETURNS void AS$BODY$ begin delete from ebd_compute_log where create_time &lt; CURRENT_TIMESTAMP(0) :: TIMESTAMP WITHOUT TIME ZONE - interval '3 months'; END;$BODY$LANGUAGE plpgsql VOLATILE; GRANT EXECUTE ON FUNCTION delete_ebd_compute_log_three_month_ago_data() TO public;","tags":[{"name":"postgresql","slug":"postgresql","permalink":"http://yoursite.com/tags/postgresql/"}]},{"title":"python| socket聊天室","date":"2020-04-06T07:55:00.000Z","path":"2020/04/06/python-聊天室/","text":"服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import socketimport timeimport tkinterfrom tkinter.scrolledtext import ScrolledTextimport threadingimport requestsimport tkinterfrom socket import *from time import ctimefrom tkinter import * global Text_Show # 调用人工智能对话的函数，返回人工智能回答 def AI_Talk(s): print(s) response &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.tuling123.com&#x2F;openapi&#x2F;api&quot;, data&#x3D;&#123; &quot;key&quot;: &quot;4105cb6db8c54f5db470b6c0ee42d24b&quot;, &quot;info&quot;: s&#125;) response &#x3D; response.json() answer &#x3D; response[&#39;text&#39;] return answer # 线程二函数，用来进行对话 def Sever_Thread(sock, caddr): Text_Show.insert(&#39;end&#39;, &quot;客户端@&quot; + str(caddr[1]) + &quot;已连接!\\n&quot;) while True: # 接收数据 data &#x3D; str(sock.recv(1024).decode(&#39;UTF-8&#39;)) if data &#x3D;&#x3D; &quot;quit&quot;: Text_Show.insert(&#39;end&#39;, &quot;客户端@&quot; + str(caddr[1]) + &quot;终止了对话\\n&quot;) Text_Show.see(tkinter.END) break else: Text_Show.insert(&#39;end&#39;, &quot;来自客户端@&quot; + str(caddr[1]) + &quot;的消息为：&quot; + data + &#39;\\n&#39;) Text_Show.see(tkinter.END) # 发送数据 time.sleep(0.2) data &#x3D; AI_Talk(data) # # data &#x3D; &#39;请输入发送至客户端的数据: 123123&#39; #如果要手动输入的话就要设置好线程sleep时间不然还没有输入，就已经到其他线程了，就会发不出去。 sock.sendall(bytes(data, &#39;UTF-8&#39;)) sock.close() # 线程一函数，监听端口，一旦有客户端接入，开启线程二 def Sever_Accept(ss): while True: sock, caddr &#x3D; ss.accept() Thread2 &#x3D; threading.Thread(target&#x3D;Sever_Thread, args&#x3D;(sock, caddr)) Thread2.daemon &#x3D; True # 线程守护 Thread2.start() # 服务器初始化def Sever_Init(): HOST &#x3D; &#39;&#39; PORT &#x3D; 4700 ADDR &#x3D; (HOST, PORT) ss &#x3D; socket(AF_INET, SOCK_STREAM, 0) ss.bind(ADDR) ss.listen(20) # 允许最大监听数 Thread1 &#x3D; threading.Thread(target&#x3D;Sever_Accept, args&#x3D;(ss,)) Thread1.daemon &#x3D; True # 线程守护 Thread1.start() # 主函数 if __name__ &#x3D;&#x3D; &quot;__main__&quot;: root &#x3D; tkinter.Tk() root.title(&quot;聊天小程序服务器端 &quot;) frame1 &#x3D; Frame(root) frame1.pack() IP_Show_Label &#x3D; Label(frame1, text&#x3D;&quot;默认IP:127.0.0.1\\n默认端口为6000\\n无法更改!!!&quot;) IP_Show_Label.pack(side&#x3D;&#39;left&#39;) frame2 &#x3D; Frame(root) frame2.pack() Text_Show &#x3D; ScrolledText(frame2, width&#x3D;100, height&#x3D;30) Text_Show.bind(&quot;&lt;KeyPress&gt;&quot;, lambda e: &quot;break&quot;) Text_Show.pack(side&#x3D;&quot;bottom&quot;, fill&#x3D;&#39;both&#39;, expand&#x3D;True) Sever_Init() root.mainloop() 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import socketimport timeimport tkinterfrom tkinter.scrolledtext import ScrolledTextimport threadingimport requestsimport tkinterfrom socket import *from time import ctimefrom tkinter import * global cs, Text_Show, Send_Show # 发送按键的函数def Click_Send(): sendData &#x3D; Send_Show.get() # 获取输入内容 if sendData &#x3D;&#x3D; &#39;quit&#39;: Text_Show.insert(tkinter.END, &quot;与服务器连接已断开&quot; + &quot;\\n&quot;) Text_Show.see(tkinter.END) cs.sendall(bytes(sendData, encoding&#x3D;&quot;utf8&quot;)) cs.close() else: Text_Show.insert(tkinter.END, &quot;客户端:&quot; + sendData + &quot;\\n&quot;) Text_Show.see(tkinter.END) cs.sendall(bytes(sendData, encoding&#x3D;&quot;utf8&quot;)) Send_Show.delete(0, END) # 线程函数，循环接受客户端消息def Receive_Data(): while True: accept_data &#x3D; str(cs.recv(1024), encoding&#x3D;&quot;utf8&quot;) Text_Show.insert(tkinter.END, &quot;服务器:&quot; + accept_data + &quot;\\n&quot;) Text_Show.see(tkinter.END) # 主函数if __name__ &#x3D;&#x3D; &quot;__main__&quot;: # 初始化GUI root &#x3D; tkinter.Tk() root.title(&quot;聊天小程序客户端 &quot;) # 顶部显示部分 frame1 &#x3D; Frame(root) frame1.pack() IP_Show_Label &#x3D; Label(frame1, text&#x3D;&quot;本程序默认IP:127.0.0.1\\n默认端口为6000\\n无法更改!!!&quot;) IP_Show_Label.pack(side&#x3D;&#39;left&#39;) # 中部聊天框显示部分 frame2 &#x3D; Frame(root) frame2.pack() Text_Show &#x3D; ScrolledText(frame2, width&#x3D;70, height&#x3D;15) Text_Show.bind(&quot;&lt;KeyPress&gt;&quot;, lambda e: &quot;break&quot;) Text_Show.pack(side&#x3D;&quot;bottom&quot;, fill&#x3D;&#39;both&#39;, expand&#x3D;True) # 底部消息发送部分 frame3 &#x3D; Frame(root) frame3.pack() e3 &#x3D; StringVar() Send_Show &#x3D; Entry(frame3, textvariable&#x3D;e3, width&#x3D;60) buttontext2 &#x3D; tkinter.StringVar() buttontext2.set(&#39;发送&#39;) button_Send &#x3D; tkinter.Button(frame3, width&#x3D;10, textvariable&#x3D;buttontext2, command&#x3D;Click_Send) Send_Show.pack(side&#x3D;&quot;left&quot;) button_Send.pack(side&#x3D;&quot;left&quot;) frame3.pack() # 初始化TCP协议 HOST &#x3D; &#39;127.0.0.1&#39; PORT &#x3D; 4700 BUFSIZ &#x3D; 1024 ADDR &#x3D; (HOST, PORT) cs &#x3D; socket(AF_INET, SOCK_STREAM, 0) cs.connect(ADDR) thread &#x3D; threading.Thread(target&#x3D;Receive_Data) thread.start() root.mainloop() 效果","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"爬虫|基于redis搭建IP代理池","date":"2020-04-06T07:46:00.000Z","path":"2020/04/06/爬虫-基于redis搭建IP代理池/","text":"前言爬虫爬取网页数据时由于频繁访问会被锁定IP，返回错误响应码以及验证字母验证，可以动态使用ip代理解决。代理服务可以自己搭建，也可以购买收费的强力代理服务更靠谱。 基于redis的ip池示例： 搭建环境： 123456windows下载地址：https:&#x2F;&#x2F;github.com&#x2F;MicrosoftArchive&#x2F;redis&#x2F;releases#下载zip解压即可启动redis：运行redis-server.exe Linux安装：sudo apt-get install redis-server启动redis：运行redis-server 安装启动： 部署本地ip爬虫 12345#下载源码git clone git@github.com:jhao104&#x2F;proxy_pool.git或者直接到https:&#x2F;&#x2F;github.com&#x2F;jhao104&#x2F;proxy_pool 下载zip文件，解压出来 安装依赖： 12#进入项目目录执行pip命令 也可以手动安装pip install -r requirements.txt 配置项目： 12345678910111213141516171819202122232425262728# Config&#x2F;setting.py 为项目配置文件 # 配置DB DATABASES &#x3D; &#123; &quot;default&quot;: &#123; &quot;TYPE&quot;: &quot;SSDB&quot;, # 如果使用SSDB或redis数据库，均配置为SSDB &quot;HOST&quot;: &quot;127.0.0.1&quot;, # db host &quot;PORT&quot;: 6379, # db port redis默认6379 &quot;NAME&quot;: &quot;proxy&quot;, # 默认配置 &quot;PASSWORD&quot;: &quot;&quot; # db password &#125;&#125; # 配置 ProxyGetterPROXY_GETTER &#x3D; [ &quot;freeProxyFirst&quot;, # 这里是启用的代理抓取函数名，可在ProxyGetter&#x2F;getFreeProxy.py 扩展 &quot;freeProxySecond&quot;, ....] # 配置 API服务 SERVER_API &#x3D; &#123; &quot;HOST&quot;: &quot;0.0.0.0&quot;, # 监听ip, 0.0.0.0 监听所有IP &quot;PORT&quot;: 5010 # 监听端口&#125;#上面配置启动后，代理池访问地址为 http:&#x2F;&#x2F;127.0.0.1:5010 启动项目： 12345678# 如果你的依赖已经安全完成并且具备运行条件,可以直接在Run下运行main.py# 到Run目录下:&gt;&gt;&gt;python main.py # 如果运行成功你应该看到有4个main.py进程 # 你也可以分别运行他们,# 依次到Api下启动ProxyApi.py,Schedule下启动ProxyRefreshSchedule.py和ProxyValidSchedule.py即可. 启动查看抓取的ip：http://127.0.0.1:5010/get_all/ 项目提供内置API: 爬虫动态代理1234567891011121314151617181920212223def get_proxy(): #可以换成我的Api return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get&#x2F;&quot;).text def getURL(self, url, redirects&#x3D;False, tries_num&#x3D;6, sleep_time&#x3D;0.5, time_out&#x3D;1000, max_retry&#x3D;6, ): #从ip池动态获取一个ip proxy &#x3D; get_proxy() try: res &#x3D; requests.Session() # res &#x3D; requests.get(url,headers&#x3D;self.randHeader(), allow_redirects&#x3D;redirects, timeout&#x3D;time_out) res &#x3D; requests.get(url,headers&#x3D;self.randHeader(), allow_redirects&#x3D;redirects, timeout&#x3D;time_out, proxies&#x3D;&#123;&quot;http&quot;: &quot;http:&#x2F;&#x2F;&#123;&#125;&quot;.format(proxy), &quot;https&quot;: &quot;https:&#x2F;&#x2F;&#123;&#125;&quot;.format(proxy)&#125;) res.raise_for_status() # 如果响应状态码不是 200，就主动抛出异常 except requests.RequestException as e: sleep_time_p &#x3D; sleep_time_p + 10 time_out_p &#x3D; time_out_p + 10 tries_num_p &#x3D; tries_num_p - 1 # 设置重试次数，最大timeout 时间和 最长休眠时间 if tries_num_p &gt; 0: time.sleep(sleep_time_p) print (self.getCurrentTime(), url, &#39;URL Connection Error: 第&#39;, max_retry - tries_num_p, u&#39;次 Retry Connection&#39;, e) return self.getURL(url, &#39;False&#39;, tries_num_p, sleep_time_p, time_out_p, max_retry) return res","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"爬虫| 基于高德api接口抓取景区/小区边界数据","date":"2020-04-06T07:10:00.000Z","path":"2020/04/06/爬虫-基于高德api接口抓取景区-小区边界数据/","text":"爬虫网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 Python爬虫Python，丰富的第三方库十分强大，简单几行代码便可实现你想要的功能，更重要的，Python也是数据挖掘和分析的好能手。这样爬取数据和分析数据一条龙的服务都用Python 工作流程123456789抓取HTML页面：HTTP请求的处理： urllib, urlib2, requests 处理器的请求可以模拟浏览器发送请求，获取服务器响应的文件解析服务器相应的内容:re, xpath, BeautifulSoup(bs4), jsonpath, pyquery等使用某种描述性语言来给我们需要提取的数据定义一个匹配规则，符合这个规则的数据就会被匹配采集动态HTML，验证码的处理通用动态页面采集： Selenium + PhantomJS:模拟真实浏览器加载JS验证码处理: Tesseract机器学习库，机器图像识别系统 爬虫框架(Scrapy)Scrapy框架 : 12345678特点： 高定制性，高性能（异步网络框架twisted）-&gt;数据下载快，提供了数据存储，数据下载，提取规则等组件 分布式策略： scrapy redis：在scarpy基础上添加了以redis数据库为核心的一套组件,主要在redis做请求指纹去重、请求分配、数据临时存储爬虫、反爬虫、反反爬虫之间的斗争: User-Agent, 代理, 验证码, 动态数据加载, 加密数据 爬取高德数据边界高德api接口地址：1234567https:&#x2F;&#x2F;lbs.amap.com&#x2F;api&#x2F;webservice&#x2F;guide&#x2F;api&#x2F;search如果不是高德开发者可以申请为开发者第一步，申请”Web服务API”密钥（Key）；第二步，拼接HTTP请求URL，第一步申请的Key需作为必填参数一同发送；第三步，接收HTTP请求返回的数据（JSON或XML格式），解析数据。如无特殊声明，接口的输入参数和输出数据编码全部统一为UTF-8。 爬取思路通过高德搜索接口得到附近小区搜索列表解析后获取到正确小区的id。其中city是城市代码,可以通过浏览器手工获取到。words是搜索的具体风景区名称。 1https:&#x2F;&#x2F;restapi.amap.com&#x2F;v3&#x2F;place&#x2F;text?key&#x3D;4b86820a7590de60e4f81f53e59ae17f&amp;citylimit&#x3D;true&amp;output&#x3D;json&amp; 为申请的密钥，申请详细步骤文档有说明1234&#96;&#96;&#96;keywords&#96;&#96;&#96; 查询的关键词，如景区&#x2F;小区名称&#96;&#96;&#96;city&#96;&#96;&#96; 查询的目标城市示例 ： https://restapi.amap.com/v3/place/text?key=4b86820a7590de60e4f81f53e59ae17f&amp;citylimit=true&amp;output=json&amp;keywords=中山陵景区&amp;city=南京 1234返回结果为json字符串&lt;img alt&#x3D;&quot;&quot; class&#x3D;&quot;has&quot; height&#x3D;&quot;250&quot; src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2019010410201027.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwMjUyNw&#x3D;&#x3D;,size_16,color_FFFFFF,t_70&quot; width&#x3D;&quot;1200&quot;&gt;提取景区&#x2F;小区的&#96;&#96;&#96;id&#96;&#96;&#96;：&#96;&#96;&#96;B0FFHVEECG 爬取方案方案1 ：然后通过poiid调用另外一个接口查询该景区/小区 1https:&#x2F;&#x2F;ditu.amap.com&#x2F;detail&#x2F;get&#x2F;detail?id&#x3D;B0FFHVEECG 参数 id 填写上面获取到的 poiid=B0FFHVEECG 请求返回结果：将返回的结果转成json然后逐层提取出来 存入数据库或者csv文档 123456789101112def info(self, response): meta &#x3D; response.meta data &#x3D; json.loads(response.text) print(data) try: if data[&quot;status&quot;] &#x3D;&#x3D; &quot;1&quot;: spec &#x3D; data[&quot;data&quot;][&quot;spec&quot;] border &#x3D; spec[&quot;mining_shape&quot;][&quot;shape&quot;] print(&quot;border &quot;,border) AllCityDataSQL().UpdateXcJingDianiData((meta[&quot;id&quot;]),border) except: print(&quot;查询错误~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot; + meta[&quot;url&quot;]) 方案2： 通过poiid查找边界信息，红色部分可以替换成其他城市代码（身份证前6位）和景区id 接口地址：https://gaode.com/service/poiInfo?query_type=IDQ&amp;pagesize=20&amp;pagenum=1&amp;qii=true&amp;cluster_state=5&amp;need_utd=true&amp;utd_sceneid=1000&amp;div=PC1000&amp;addr_poi_merge=true&amp;is_classify=true&amp;zoom=11&amp;id=B022F0071G&amp;city=341003 请求返回结果： 由一堆坐标组成的数值1&lt;img alt&#x3D;&quot;&quot; class&#x3D;&quot;has&quot; height&#x3D;&quot;331&quot; src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190104104204104.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDkwMjUyNw&#x3D;&#x3D;,size_16,color_FFFFFF,t_70&quot; width&#x3D;&quot;1200&quot;&gt; 将返回的结果转成json ，然后逐层提取出来返回的value字段值还需修改一下，将_换成，才能使用存入数据库或者csv文档 12345#### 常见问题高德的反扒机制： 错误数据接口异常跳转第三方接口 ```推荐使用ip代理搭建一个ip池：博客 常用反反爬机制：csdn地址 PhantomJS + selenium 防反爬：csdn地址","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Java|基于springBoot的开源分布式系统","date":"2020-04-06T06:43:00.000Z","path":"2020/04/06/基于springBoot的开源分布式系统/","text":"springBoot123Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。使基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题---习惯大于约定。 四大核心1234567SpringBoot的四大核心：自动配置：针对很对spring应用程序常见的应用功能，SpringBoot能自动提供相关配置起步依赖：起步依赖和普通依赖的区别在于我们不需要传入版本号，它会根据springboot的版本号来进行依赖，解决了我们的版本不兼容性。命令行界面：这是SpringBoot的可选特性，借此 你只需要代码就能完成完整的应用程序，无需传统项目构建。（一般用于轻量级开发和测试）Actuator：是SpringBoot的一个附加功能，可以帮助你在应用程序生产环境时监视和管理应用程序。0特别对于微服务管理十分有意义。自动配置：简单的说 就是你写好代码 开启自动配置之后 springboot 会去找所有你配置好的bean 进行初始化 和 注入 等等操作 优点12345678SpringBoot主要优点：帮助开发者快速搭建Spring框架，无需配置自动整合第三方框架。帮助开发者快速启动一个web容器，内嵌servlet容器，降低了对环境的要求，可以使用命令直接执行项目，应用可用jar包执行：java -jar。继承了原有的Spring框架的优秀基因。简化了Spring的使用过程，提高了开发效率。提供了starter POM，可以非常方便 的对包进行管理，极大程度的减少了jar hell 和dependency hell。运行中对应用状态的监控。 springBoot 入门示例 ：csdn地址 iBase4j说明123456iBase4J是Java语言的分布式系统架构。 使用Spring整合开源框架。使用Maven对项目进行模块化管理，提高项目的易开发性、扩展性。系统包括4个子系统：系统管理Service、系统管理Web、业务Service、业务Web。系统管理：包括用户管理、权限管理、数据字典、系统参数管理等等。业务相关：您的业务开发。可以无限的扩展子系统，子系统之间使用Dubbo或MQ进行通信。 特点12345678910111. 数据库：Druid数据库连接池，监控数据库访问性能，统计SQL的执行性能。 数据库密码加密，加密方式请查看PropertiesUtil，decryptProperties属性配置需要解密的key。2. 持久层：mybatis持久化，使用MyBatis-Plus优化，减少sql开发量；aop切换数据库实现读写分离。Transtraction注解事务。3. MVC： 基于spring mvc注解,Rest风格Controller。Exception统一管理。4. 调度：Spring+quartz, 可以查询、修改周期、暂停、删除、新增、立即执行，查询执行记录等。5. 基于session的国际化提示信息，职责链模式的本地语言拦截器,Shiro登录、URL权限管理。会话管理，强制结束会话。6. 缓存和Session：注解redis缓存数据；shiro实现redis分布式session同步，重启服务会话不丢失。7. 多系统交互：Dubbo,ActiveMQ多系统交互，ftp&#x2F;sftp&#x2F;fastdafs发送文件到独立服务器，使文件服务分离。8. 前后端分离：没有权限的文件只用nginx代理即可。9. 日志：log4j2打印日志，业务日志和调试日志分开打印。同时基于时间和文件大小分割日志文件。10. QQ、微信、新浪微博第三方登录。11. 工具类：excel导入导出，汉字转拼音，身份证号码验证，数字转大写人民币，FTP&#x2F;SFTP&#x2F;fastDFS上传下载，发送邮件，redis缓存，加密等等。 Spring，SpringBoot，SpringMVC，Mybatis，mybatis-plus，motan/dubbo分布式，Redis缓存，Shiro权限管理，Spring-Session单点登录，Quartz分布式集群调度，Restful服务，QQ/微信登录，App token登录，微信/支付宝支付；日期转换、数据类型转换、序列化、汉字转拼音、身份证号码验证、数字转人民币、发送短信、发送邮件、加密解密、图片处理、excel导入导出、FTP/SFTP/fastDFS上传下载、二维码、XML读写、高精度计算、系统配置工具类等等 搭建GitHub地址:https://github.com/iBase4J/iBase4J-SpringBoot项目依赖：redis zookeeper actionmqredis安装：https://www.cnblogs.com/M-LittleBird/p/5902850.htmlzookeeper 安装：https://www.cnblogs.com/lsdb/p/7297731.htmlactiveMq 安装 ：https://blog.csdn.net/mr_haixin/article/details/80418204 git clone 项目 1git clone https:&#x2F;&#x2F;github.com&#x2F;iBase4J&#x2F;iBase4J-SpringBoot.git 导入开发工具 idea 配置环境 ：idea2019 jdk1.8 mysql8 导入sql文件 启动脚本 依次导入脚本 修改配置文件，配置本地环境 默认加密密码：buzhidao =,= 自定义生成密码 启动脚手架 12SysServiceApplication.java runSysWebApplication.java run Api地址访问：http://localhost:8088/swagger-ui.html#/ 访问项目还需要配置 nginx 1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; # 静态页面目录 root D:\\workspace\\iBase4J\\iBase4J-UI\\iBase4J-UI-AngularJS; # 默认首页 index index.html; location &#x3D; &#x2F; &#123; index login.html index.html index.htm; &#125; # 用户浏览器端的缓存设置 location ~* \\.(css|js|jpg|jpeg|gif|png|swf|htm|html|json|xml|svg|woff|ttf|eot|map|ico|woff2|apk)$ &#123; proxy_cache_valid 200 304 4h; expires 4h; &#125; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; location &#x2F;app&#x2F; &#123; # 动态页面,交给tomcat处理 proxy_pass http:&#x2F;&#x2F;127.0.0.1:8090; &#125; location &#x2F; &#123; # 动态页面,交给tomcat处理 proxy_pass http:&#x2F;&#x2F;127.0.0.1:8088; &#125; &#125; 搭建成功访问 ：http://localhost/admin/111111","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Java|微服务搭建","date":"2020-04-06T03:08:00.000Z","path":"2020/04/06/微服务搭建/","text":"微服务微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底去掉耦合，每一个微服务提供单个业务功能，一个服务只做一件事。从技术角度讲就是一种小而独立的处理过程，类似与进程的概念，能够自行单独启动或销毁，可以拥有自己独立的数据库 微服务框架:spring -cloud1234567891011121314Spring Cloud是一个完整的微服务解决方案，它提供分布式情况下的各种解决方案合集。而Dubbo是一款高性能的Java RPC框架。Spring Cloud生态和Dubbo生态随着技术的发展，会逐渐的融合互补总体架构 Service Provider： 暴露服务的提供方。 Service Consumer：调用远程服务的服务消费方。 EureKa Server： 服务注册中心和服务发现中心基础组件： 服务治理： Spring Cloud Eureka 客户端负载均衡： Spring Cloud Ribbon 服务容错保护： Spring Cloud Hystrix 声明式服务调用： Spring Cloud Feign API 网关服务：Spring Cloud Zuul 分布式配置中心： Spring Cloud Config spring-cloud详解: csdn地址 基于meven的spring - cloud搭建环境： 1ide工具：idea jdk版本:1.8 数据库：mysql8 工程目录： 构建父工程 新建一个空工程: File -&gt; New -&gt; New Project 创建完成有弹出框 新建modules，点击 + 号，新建一个父工程，也就是一个父 module。然后我们选择 maven 工程，选择 jdk 版本和模板，模板也可以不选择，我这里就没有选择，自己搭建即可; 在pom文件中设置spring boot的parent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Edgware.SR1&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;1.5.10.RELEASE&lt;/spring-boot.version&gt; &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt; &lt;mybatis.version&gt;1.3.2&lt;/mybatis.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 定义 spring cloud 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 spring boot 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 定义 mysql 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 mybatis 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 定义 lombok 版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 父工程配置完了，子模块可以直接通过 &lt;parent&gt; 标签引用父工程的依赖包 构建common模块(公共服务模块)创建microservice-common模块（公共模块）供其子模块调用 在父工程中添加common子模块，右键microservice - new - module 123456789101112131415161718192021222324252627282930312. 在pom中添加依赖包&#96;&#96;&#96; &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.demo&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&#x2F;microservice&#x2F;pom.xml&lt;&#x2F;relativePath&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;microservice-common&lt;&#x2F;artifactId&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;project&gt; 在scr/main/java/下创建实体类，添加公共实体类供其他服务调用 123456789101112131415161718192021222324252627282930313233343536373839package com.demo.springcloud.entity; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors; /** * 订单实体 *@AllArgsConstructor 注解：表示生成带有所有属性的构造方法 *@NoArgsConstructor 注解：表示生成不带参数的构方法 *@Data 注解：表示生成get和set方法 */@AllArgsConstructor@NoArgsConstructor@Datapublic class TOrder &#123; /** * 主键id */ private Long id; /** * 商品名称 */ private String name; /** * 商品价格 */ private Double price; /** * 所存的数据库名称 */ private String dbSource;&#125; 将common打包成jar文件，点击maven 分别 clean和 install一下 12345678910111213141516171819202122232425262728### 创建provider模块(服务提供者)创建服务提供者模块microservice-provider，添加方式和microservice-common一样。服务提供模块，主要负责在表中查询出订单信息，然后将信息通过接口提供给调用方，所以在该模块中，我们需要整合一下 mybatis：1. 在pom文件中配置整合的依赖包&#96;&#96;&#96;bash# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 配置application.yml 1234567891011121314151617181920# 服务端口号server: port: 8001 # 数据库地址datasource: url: localhost:3306&#x2F;demo spring: application: name: microservice-order # 对外暴露的服务名称 datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;$&#123;datasource.url&#125;?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&amp;autoReconnect&#x3D;true&amp;failOverReadOnly&#x3D;false&amp;maxReconnects&#x3D;10 username: root password: root hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000 创建数据持久层接口 12345678910 public interface OrderMapper &#123; @Select(&quot;select * from microservice where id &#x3D; #&#123;id&#125;&quot;) TOrder findById(Long id); @Select(&quot;select * from microservice&quot;) List&lt;TOrder&gt; findAll(); &#125; 创建业务层接口以及实现类 123456789101112131415161718192021222324//业务层接口public interface OrderService &#123; TOrder findById(Long id); List&lt;TOrder&gt; findAll();&#125; //接口实现类@Servicepublic class OrderServiceImpl implements OrderService &#123; @Resource private OrderMapper orderMapper; public TOrder findById(Long id) &#123; return orderMapper.findById(id); &#125; public List&lt;TOrder&gt; findAll() &#123; return orderMapper.findAll(); &#125;&#125; 创建服务控制层 1234567891011121314151617@RestController@RequestMapping(\"/provider/order\")public class OrderProviderController &#123; @Resource private OrderService orderService; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return orderService.findById(id); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return orderService.findAll(); &#125;&#125; 创建服务启动类 123456789@SpringBootApplication@MapperScan(&quot;com.itcodai.springcloud.dao&quot;)public class OrderProvider &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderProvider.class, args); &#125;&#125; 数据结构 1服务提供者模块搭建完了可以启动测试，浏览器输入：localhost:8001&#x2F;provider&#x2F;order&#x2F;get&#x2F;list 创建consumer模块(订单消费者)新建子模块的方法和上面两个子模块一样，在命名的时候命名为 microservice-consumer 即可。 microservice-consumer 模块主要是用来调用 microservice-provider模块提供的订单信息，所以在 microservice-consumer 模块中我们不需要引入 mybatis 和 mysql 相关的依赖; 在pom文件配置依赖包 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../microservice/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;microservice-consumer&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 当前Module需要用到的依赖，按自己需求添加，版本号在父类已经定义了，这里不需要再次定义 --&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的 microservice-common 通用包，可以使用common模块中的Order类 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring boot web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建RestTmplate类。在微服务都是以 HTTP 接口的形式暴露自身服务的，因此在调用远程服务时就必须使用 HTTP 客户端。Spring Boot 中使用的是 RestTemplate，首先，我们写一个配置类，将 RestTemplate 作为一个 Bean 交给 Spring 来管理 12345678@Configurationpublic class RestTmplateConfig &#123; @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 有了RestTmplate，接下来我们可以在 Controller 中注入该 RestTemplate 来调用 microservice-provider提供的服务了 12345678910111213141516171819202122//@RestController 相当于Controller注释加ResponesBody注释@RestController@RequestMapping(\"/consumer/order\")public class OrderConsumerController &#123; // 订单服务提供者模块的 url 前缀 private static final String ORDER_PROVIDER_URL_PREFIX = \"http://localhost:8001\"; @Resource private RestTemplate restTemplate; @GetMapping(\"/get/&#123;id&#125;\") public TOrder getOrder(@PathVariable Long id) &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/\" + id, TOrder.class); &#125; @GetMapping(\"/get/list\") public List&lt;TOrder&gt; getAll() &#123; return restTemplate.getForObject(ORDER_PROVIDER_URL_PREFIX + \"/provider/order/get/list\", List.class); &#125;&#125; 订单消费者模块搭建完了可以启动测试一下 浏览器访问： 1http:&#x2F;&#x2F;localhost:8080&#x2F;consumer&#x2F;order&#x2F;get&#x2F;list 返回结果，说明服务调用成功 可以看到通过订单消费者调用服务提供者暴露的服务，实现了每个服务专注于自身的逻辑，服务之间解耦合。 总结流程订单消费模块不直接请求数据库，而是通过 http 远程调用订单提供模块的服务来获取订单信息。也就是说，在微服务里，每个服务只关注自身的逻辑和实现，不用管其他服务的实现，需要获取某个服务的数据时，只要调用该服务提供的接口即可获取相应的数据。实现了每个服务专注于自身的逻辑，服务之间解耦合; 扩展Eureka整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88953312 Ribbon整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88977376 feign整合1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;89249172 微服务框架Dubbo和Spring cloud差异1https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40902527&#x2F;article&#x2F;details&#x2F;88579521 代码地址：github地址","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":" Java|设计模式总结","date":"2020-04-06T02:40:00.000Z","path":"2020/04/06/java/","text":"设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出命令模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.designpatter.demo; /**** * 设计模式 * * 命令模式 * 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通， * 这样方便将命令对象进行储存、传递、调用、增加与管理。 * * 命令模式的主要优点如下。 * 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 * 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 * 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 * 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 * * 其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 */public class CommandPatterDemo &#123; public static void main(String[] args) &#123; Context command = new Context(new read()); command.execute(); &#125; public interface Command &#123; void execute(); &#125; public static class read implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始读取数据\"); &#125; &#125; public static class copy implements Command&#123; @Override public void execute() &#123; System.out.println(\"开始复制数据\"); &#125; &#125; public static class Context&#123; private Command command; public Context(Command command) &#123; this.command = command; &#125; public void execute()&#123; this.command.execute(); &#125; &#125;&#125; 装饰模式1234567891011121314151617181920212223242526272829303132333435363738394041package com.designpatter.demo; /** * 装饰模式 * * 介绍其适用的应用场景，装饰模式通常在以下几种情况使用。 * 当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 * 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。 * 当对象的功能要求可以动态地添加，也可以再动态地撤销时。 * * 装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream， * OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、 * FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。 * */public class DecoratePatternDemo &#123; public static void main(String[] args) &#123; SuperPerson superPerson = new SuperPerson(new Person()); superPerson.eat(); &#125; static class Person&#123; public void eat()&#123; System.out.println(\"吃饭\"); &#125; &#125; static class SuperPerson&#123; private Person person; public SuperPerson(Person person) &#123; this.person = person; &#125; public void eat()&#123; System.out.println(\"喝两口\"); this.person.eat(); System.out.println(\"抽两根\"); &#125; &#125;&#125; 构建者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.designpatter.demo;/** * * 建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。 * 它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 * * 该模式的主要优点如下： * 各个具体的建造者相互独立，有利于系统的扩展。 * 客户端不必知道产品内部组成的细节，便于控制细节风险。 * * 其缺点如下： * 产品的组成部分必须相同，这限制了其使用范围。 * 如果产品的内部变化复杂，该模式会增加很多的建造者类。 * * 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 * */public class WithoutPatternDemo &#123; public static void main(String[] args) &#123; Student student = new ConCreateStudent() .setSpeak1(\"test1\") .setSpeak2(\"test2\") .setSpeak3(\"test3\") .build(); System.out.println(student); &#125; public static class Student&#123; private String speak1; private String speak2; private String speak3; public void setSpeak1(String speak1) &#123; this.speak1 = speak1; &#125; public void setSpeak2(String speak2) &#123; this.speak2 = speak2; &#125; public void setSpeak3(String speak3) &#123; this.speak3 = speak3; &#125; public String getSpeak1() &#123; return speak1; &#125; public String getSpeak2() &#123; return speak2; &#125; public String getSpeak3() &#123; return speak3; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"speak1='\" + speak1 + '\\'' + \", speak2='\" + speak2 + '\\'' + \", speak3='\" + speak3 + '\\'' + '&#125;'; &#125; &#125; public interface Buidler&#123; Buidler setSpeak1(String speak1); Buidler setSpeak2(String speak2); Buidler setSpeak3(String speak3); Student build(); &#125; public static class ConCreateStudent implements Buidler &#123; Student student = new Student(); @Override public Buidler setSpeak1(String speak1) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak1(speak1); return this; &#125; @Override public Buidler setSpeak2(String speak2) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak2(speak2); return this; &#125; @Override public Buidler setSpeak3(String speak3) &#123; System.out.println(\"复杂的逻辑判断\"); student.setSpeak3(speak3); return this; &#125; @Override public Student build() &#123; return student; &#125; &#125;&#125; 组合模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.designpatter.demo; import java.util.ArrayList;import java.util.List;/** * 组合模式的主要优点有： * 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； * 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； * * 其主要缺点是： * 设计较复杂，客户端需要花更多时间理清类之间的层次关系； * 不容易限制容器中的构件； * 不容易用继承的方法来增加构件的新功能； * */public class WhihoutPatternDemo &#123; public static void main(String[] args) &#123; Department coreDep = new Department(\"主部门\"); Department subDep1 = new Department(\"子部门1\"); Department subDep2 = new Department(\"子部门2\"); Department leafDep1 = new Department(\"叶子部门1\"); Department leafDep2 = new Department(\"叶子部门2\"); Department leafDep3 = new Department(\"叶子部门3\"); subDep1.child.add(leafDep1); subDep2.child.add(leafDep2); subDep2.child.add(leafDep3); coreDep.child.add(subDep1); coreDep.child.add(subDep2); coreDep.remove(); &#125; static class Department&#123; private String name; private List&lt;Department&gt; child = new ArrayList&lt;Department&gt;(); public Department(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public List&lt;Department&gt; getChild() &#123; return child; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setChild(List&lt;Department&gt; child) &#123; this.child = child; &#125; void remove()&#123; if(this.child.size() &gt; 0)&#123; for(Department department:this.child)&#123; department.remove(); &#125; &#125; System.out.println(\"删除\"+name); &#125; &#125;&#125; 程序开发遵守原则1.开闭原则定义：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 作用：开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。可以提高代码的可复用性粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。可以提高软件的可维护性遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。实现：可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 2.里氏替换原则定义： 里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 作用： 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。实现： 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 3.依赖倒置原则定义：依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 作用： 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。实现： 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 4.单一职责原则 定义：一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 作用： 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其 他功能的影响实现:单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用. 5.接口隔离原则定义： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。作用： 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。实现： 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 6.迪米特原则 定义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 作用： 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。实现： 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 7.合成复用原则定义：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。作用： 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。实现： 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用 23种设计模式 1234567891011121314151617181920212223 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 * 23种设计模式以及设计原则","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]}]